# CODEX: Make It Happen

Sequenced task list with exact AI requests to implement the full vision described in `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md`, informed by `.ANALYSIS-GIT-ENHANCEMENTS.md` and `.ANALYSIS-GITHUB-VS-GIT.md`.

Tasks are ordered by dependency chain â€” each task builds on the outputs of prior tasks. Within each phase, tasks are listed in execution order.

---

## Phase 0: Foundation â€” Security & Reliability (Week 1â€“2)

These tasks harden the existing `.GITOPENCLAW/` prototype before adding new features. They have no external dependencies and unblock everything that follows.

### Task 0.1 â€” Settings Schema & Preflight Validation

**Why first:** Every subsequent task adds configuration surface. Validating config early prevents silent failures from compounding.

**AI Request:**

> Create a JSON Schema file at `.GITOPENCLAW/config/settings.schema.json` that validates the existing `settings.json` structure: `defaultProvider` (enum: "anthropic", "openai", "google", "bedrock", "ollama"), `defaultModel` (non-empty string), `defaultThinkingLevel` (enum: "none", "low", "medium", "high"). Then create a new lifecycle script `.GITOPENCLAW/lifecycle/GITOPENCLAW-PREFLIGHT.ts` that:
>
> 1. Validates `config/settings.json` against the schema (use Ajv or a lightweight inline validator).
> 2. Checks that all required files exist: `GITOPENCLAW-ENABLED.md`, `config/settings.json`, `lifecycle/GITOPENCLAW-AGENT.ts`, `lifecycle/GITOPENCLAW-ENABLED.ts`, `lifecycle/GITOPENCLAW-INDICATOR.ts`, `state/.gitignore`.
> 3. Verifies `state/.gitignore` contains entries that prevent accidental secret commits.
> 4. Exits non-zero with a descriptive error on any failure.
>
> Add this as a new step in `.github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml` between the "Guard" and "Preinstall" steps:
> ```yaml
>       - name: Preflight
>         run: bun .GITOPENCLAW/lifecycle/GITOPENCLAW-PREFLIGHT.ts
> ```
>
> Add Ajv (or chosen validator) to `.GITOPENCLAW/package.json` dependencies if needed. Update `.GITOPENCLAW/tests/phase0.test.js` to include structural assertions for the new schema file and preflight script.

---

### Task 0.2 â€” Trust-Level Gating

**Why second:** Must exist before slash commands (Task 1.1) so commands respect trust tiers from day one.

**AI Request:**

> Extend `.GITOPENCLAW/config/settings.json` and its schema (`.GITOPENCLAW/config/settings.schema.json`) with a new optional `trustPolicy` object:
>
> ```json
> {
>   "trustPolicy": {
>     "trustedUsers": [],
>     "semiTrustedRoles": ["write"],
>     "untrustedBehavior": "read-only-response"
>   }
> }
> ```
>
> Schema: `trustedUsers` is an array of GitHub usernames (strings). `semiTrustedRoles` is an array of GitHub permission levels (enum: "admin", "maintain", "write"). `untrustedBehavior` is enum: "read-only-response", "block".
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, add a trust-level resolution step after loading settings and before invoking the OpenClaw agent. The logic:
>
> 1. Read `github.actor` and their permission level from the workflow environment.
> 2. If the actor is in `trustedUsers` â†’ trust level is `trusted` (full capabilities).
> 3. Else if the actor's permission is in `semiTrustedRoles` â†’ trust level is `semi-trusted` (pass `--tools` flag to restrict to read-only tools: no bash, no file writes).
> 4. Else â†’ trust level is `untrusted` (respond with a read-only explanation or block based on `untrustedBehavior`).
>
> Export the trust resolution as a function so it can be unit-tested. Add tests in a new file `.GITOPENCLAW/tests/trust-level.test.js` covering all three tiers and edge cases (missing config, empty trustedUsers).

---

### Task 0.3 â€” Cost and Resource Boundaries

**Why third:** Sets guardrails before Task 1.1 opens up the full command surface.

**AI Request:**

> Extend `.GITOPENCLAW/config/settings.json` and its schema with a new optional `limits` object:
>
> ```json
> {
>   "limits": {
>     "maxTokensPerRun": 100000,
>     "maxToolCallsPerRun": 50,
>     "workflowTimeoutMinutes": 10
>   }
> }
> ```
>
> Schema: all three fields are positive integers; `maxTokensPerRun` minimum 1000, `maxToolCallsPerRun` minimum 1, `workflowTimeoutMinutes` minimum 1 maximum 360 (GitHub Actions supports up to 6 hours).
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, pass the `maxTokensPerRun` and `maxToolCallsPerRun` values as `--max-tokens` and `--max-tool-calls` flags (or equivalent environment variables) to the `openclaw agent` CLI invocation. After the agent completes, append a one-line JSON entry to `.GITOPENCLAW/state/usage.log` with: `timestamp`, `issueNumber`, `actor`, `tokensUsed` (from agent output), `toolCalls` (from agent output), `durationMs`. Set `merge=union` git attribute for `usage.log` in `.GITOPENCLAW/state/.gitattributes`.
>
> Validate in the preflight script (Task 0.1) that if `limits` is present, all values pass schema validation.

---

## Phase 1: Issue Chat Completeness (Week 3â€“4)

These tasks deliver the full CLI-equivalent command surface through GitHub Issue comments.

### Task 1.1 â€” Slash Command Parser

**Depends on:** Task 0.2 (trust gating), Task 0.3 (cost limits)

**AI Request:**

> Create a command parser module at `.GITOPENCLAW/lifecycle/command-parser.ts` that:
>
> 1. Accepts the raw text of an issue comment.
> 2. Detects if the first line starts with a `/` prefix (e.g., `/config set provider openai`, `/status`, `/help`, `/doctor`, `/channels status`, `/memory search query`, `/sessions list`, `/models list`, `/cron create`, `/plugins install`, `/update`, `/skills list`).
> 3. Parses the command name and arguments into a structured object: `{ command: string, args: string[], rawText: string }`.
> 4. If no `/` prefix is detected, returns `{ command: 'agent', args: [], rawText: <full comment body> }` (natural language mode â€” the existing behavior).
> 5. Exports a `parseCommand(text: string)` function and a `SUPPORTED_COMMANDS` constant listing all recognized commands with descriptions.
>
> Integrate into `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`:
> - Before invoking the agent, call `parseCommand(commentBody)`.
> - For structured commands (`/config`, `/status`, etc.), build the appropriate `openclaw <command> <args>` CLI invocation.
> - For natural language (`command === 'agent'`), use existing behavior.
> - Respect trust level from Task 0.2: semi-trusted users cannot execute mutation commands (`/config set`, `/plugins install`, `/update`).
>
> Add tests in `.GITOPENCLAW/tests/command-parser.test.js` covering: all supported commands, argument parsing, natural language fallback, unknown command handling, and trust-level gating of mutation commands.

---

### Task 1.2 â€” `/help` Command and Command Reference

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Add a `/help` command handler in the agent orchestrator (`.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`) that, when a user comments `/help` on an issue:
>
> 1. Does NOT invoke the OpenClaw agent.
> 2. Reads the `SUPPORTED_COMMANDS` list from the command parser (Task 1.1).
> 3. Posts a markdown-formatted issue comment listing all available commands with their descriptions, argument syntax, and examples. Group commands by category (Agent, Configuration, Channels, Sessions, Memory, Models, Cron, Health, Plugins, Skills).
> 4. Include a footer noting: "Commands prefixed with ðŸ”’ require trusted user access."
>
> Also generate a static reference file at `.GITOPENCLAW/docs/COMMANDS.md` containing the same information for documentation purposes.

---

### Task 1.3 â€” Rich Markdown Output Templates

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Create a module at `.GITOPENCLAW/lifecycle/output-templates.ts` that exports functions for rendering rich markdown output for structured commands:
>
> 1. `renderStatus(data)` â€” Renders a status dashboard table with agent runtime version, provider, model, memory entry count, session count, cron task count, plugin list. Uses emoji indicators (âœ…, âš ï¸, âŒ).
> 2. `renderChannelsStatus(channels)` â€” Renders a table of channel names, types, connection status.
> 3. `renderSessionsList(sessions)` â€” Renders a table of session IDs, issue numbers, turn counts, last activity timestamps.
> 4. `renderDoctorReport(checks)` â€” Renders a diagnostic report with pass/fail for each health check.
> 5. `renderConfigDiff(before, after)` â€” Renders a table showing changed configuration values.
> 6. `renderModelsList(models)` â€” Renders available models grouped by provider.
>
> Each function returns a markdown string ready to post as an issue comment. Use collapsible `<details>` sections for verbose output. Keep formatting consistent with the interaction pattern examples shown in `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md` Section 6.1.
>
> Add unit tests in `.GITOPENCLAW/tests/output-templates.test.js` verifying markdown structure for each template.

---

### Task 1.4 â€” Machine-Readable Command Policy

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Create `.GITOPENCLAW/config/command-policy.json`:
>
> ```json
> {
>   "enforcement": "enforce",
>   "allowedCommands": ["help", "status", "doctor", "config", "channels", "sessions", "memory", "models", "cron", "plugins", "skills", "update", "agent"],
>   "blockedPatterns": ["deploy", "publish", "release", "delete", "rm -rf"],
>   "requirePrefixForActions": false,
>   "actionPrefix": "/openclaw"
> }
> ```
>
> Add a companion schema file `.GITOPENCLAW/config/command-policy.schema.json`.
>
> In the command parser (Task 1.1), after parsing the command, check it against the command policy:
> 1. If `enforcement` is `"enforce"` and the command is not in `allowedCommands`, reply with an error message and exit.
> 2. Scan the raw text for any `blockedPatterns` (substring match). If found, reply with a warning and exit.
> 3. If `requirePrefixForActions` is true, only process comments that start with the `actionPrefix`.
>
> Validate the command policy file in the preflight script (Task 0.1). Add tests.

---

### Task 1.5 â€” Onboarding Wizard via Multi-Turn Issue Thread

**Depends on:** Task 1.1 (command parser), Task 1.3 (output templates)

**AI Request:**

> Implement an onboarding flow triggered when a user creates an issue titled "Setup OpenClaw" or comments `/onboard` on any issue. In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`:
>
> 1. Detect the onboarding trigger (title match or `/onboard` command).
> 2. Check if onboarding has already been completed (look for a `.GITOPENCLAW/state/onboarded.json` marker file).
> 3. If not onboarded, track onboarding state in `.GITOPENCLAW/state/onboarding/<issueNumber>.json` with fields: `currentStep` (number), `responses` (object of stepâ†’value).
> 4. Post the appropriate step prompt as an issue comment:
>    - Step 1: "Choose your LLM provider" (anthropic, openai, google)
>    - Step 2: "Choose your model" (list options based on chosen provider)
>    - Step 3: "Set thinking level" (none, low, medium, high)
>    - Step 4: "Add any trusted users?" (comma-separated GitHub usernames or "skip")
> 5. When the user replies, detect the in-progress onboarding session, parse their response, advance to the next step.
> 6. After the final step, write the completed configuration to `config/settings.json`, create `state/onboarded.json`, and post a summary comment with the final config.
>
> Use the output templates from Task 1.3 for formatting. Add tests covering the full multi-step flow.

---

## Phase 2: GitHub Pages Dashboard (Week 5â€“8)

These tasks deliver the visual web dashboard at `owner.github.io/repo`.

### Task 2.1 â€” Backend Adapter Interface

**Depends on:** Phase 1 complete (command surface exists)

**AI Request:**

> In the existing UI codebase at `ui/src/`, create a backend adapter interface at `ui/src/adapters/backend.ts`:
>
> ```typescript
> export interface BackendAdapter {
>   // Chat
>   sendMessage(sessionId: string, message: string): Promise<AgentReply>
>   getMessages(sessionId: string): Promise<Message[]>
>   // Config
>   getConfig(): Promise<Record<string, unknown>>
>   patchConfig(patch: Record<string, unknown>): Promise<void>
>   // Sessions
>   listSessions(): Promise<SessionSummary[]>
>   getSession(id: string): Promise<SessionTranscript>
>   // Memory
>   searchMemory(query: string): Promise<MemoryResult[]>
>   // Channels
>   getChannelStatus(): Promise<ChannelStatus[]>
>   // Actions
>   triggerWorkflow(inputs: Record<string, string>): Promise<WorkflowRun>
>   getWorkflowLogs(runId: number): Promise<string>
> }
> ```
>
> Define the type interfaces for `AgentReply`, `Message`, `SessionSummary`, `SessionTranscript`, `MemoryResult`, `ChannelStatus`, and `WorkflowRun`. Export the interface and types.
>
> Create `ui/src/adapters/gateway-adapter.ts` that implements `BackendAdapter` by wrapping the existing WebSocket RPC calls in `ui/src/ui/gateway.ts`. This is a pure refactor â€” extract the existing data-fetching logic into the adapter shape without changing any behavior. The existing UI components should be updated to call through the adapter rather than directly using the gateway module.
>
> Do NOT create the GitHub API adapter yet (that is Task 2.2). The goal here is to establish the interface so both adapters share the same contract.

---

### Task 2.2 â€” GitHub API Adapter

**Depends on:** Task 2.1 (adapter interface)

**AI Request:**

> Create `ui/src/adapters/github-api-adapter.ts` that implements the `BackendAdapter` interface from Task 2.1 using the GitHub REST API (via `@octokit/rest` or raw `fetch` calls with the user's OAuth token):
>
> 1. `sendMessage(sessionId, message)` â€” Creates a new comment on the issue associated with the session (looks up issue number from `.GITOPENCLAW/state/issues/` via Contents API). Returns a pending `AgentReply` (the actual reply arrives asynchronously via the workflow).
> 2. `getMessages(sessionId)` â€” Reads the JSONL session transcript from `.GITOPENCLAW/state/sessions/<id>.jsonl` via Contents API. Parses and returns as `Message[]`.
> 3. `getConfig()` â€” Reads `.GITOPENCLAW/config/settings.json` via Contents API.
> 4. `patchConfig(patch)` â€” Reads current config, merges the patch, commits the updated file via Commits API (creates a commit on the default branch).
> 5. `listSessions()` â€” Lists the `.GITOPENCLAW/state/sessions/` directory via Contents API. Returns file names and metadata.
> 6. `getSession(id)` â€” Reads and parses a specific JSONL transcript.
> 7. `searchMemory(query)` â€” Triggers a `workflow_dispatch` event with the search query as an input. Returns a placeholder; results are fetched from workflow artifacts on completion.
> 8. `getChannelStatus()` â€” Reads last workflow run status and any committed channel state files.
> 9. `triggerWorkflow(inputs)` â€” Triggers a `workflow_dispatch` on the agent workflow.
> 10. `getWorkflowLogs(runId)` â€” Fetches workflow run logs via Actions API.
>
> Store the OAuth token in `localStorage` (set during the OAuth flow in Task 2.4). Store the repository owner/name from the build-time `__GITHUB_REPO__` define. Add `@octokit/rest` to `ui/package.json` dependencies if used.

---

### Task 2.3 â€” Vite Build Configuration for GitHub Pages

**Depends on:** Task 2.2 (GitHub API adapter)

**AI Request:**

> Create a Vite config file at `ui/vite.github-pages.config.ts` for building the Lit UI as a GitHub Pages static site:
>
> ```typescript
> import { defineConfig } from 'vite'
>
> export default defineConfig({
>   base: process.env.GITHUB_PAGES_BASE || '/',
>   define: {
>     __BACKEND_MODE__: JSON.stringify('github-api'),
>     __GITHUB_REPO__: JSON.stringify(process.env.GITHUB_REPOSITORY || ''),
>   },
>   build: {
>     outDir: 'dist-pages',
>   },
> })
> ```
>
> In the UI app's initialization code (likely `ui/src/index.ts` or equivalent entry point), add backend mode detection:
>
> ```typescript
> declare const __BACKEND_MODE__: string
> declare const __GITHUB_REPO__: string
>
> const adapter = __BACKEND_MODE__ === 'github-api'
>   ? new GitHubApiAdapter(__GITHUB_REPO__)
>   : new GatewayAdapter()
> ```
>
> Add a `build:pages` script to `ui/package.json`:
> ```json
> "build:pages": "vite build --config vite.github-pages.config.ts"
> ```
>
> Ensure the build produces a complete static site in `ui/dist-pages/` including `index.html`, all JS/CSS assets, and any static assets from `ui/public/`. Add `ui/dist-pages/` to `.gitignore`.

---

### Task 2.4 â€” GitHub OAuth Authentication Flow

**Depends on:** Task 2.3 (Pages build config)

**AI Request:**

> Create an OAuth authentication flow for the GitHub Pages app. In `ui/src/auth/`:
>
> 1. `github-oauth.ts` â€” Implements the GitHub OAuth web application flow:
>    - `startOAuthFlow()` â€” Redirects to `https://github.com/login/oauth/authorize` with `client_id`, `redirect_uri` (the Pages URL), and `scope` (repo, read:user).
>    - `handleOAuthCallback()` â€” Extracts the `code` from the URL query string after redirect. Exchanges it for an access token. Note: The code-to-token exchange requires a server-side step (GitHub does not support CORS for the token endpoint). Options: (a) use a lightweight serverless function (Cloudflare Worker, Vercel function) as a proxy, or (b) use a GitHub OAuth App with the Device Flow (which is fully client-side). Implement option (b) â€” the Device Flow.
>    - `getStoredToken()` â€” Reads the OAuth token from `localStorage`.
>    - `clearToken()` â€” Removes the token and redirects to login.
>
> 2. `auth-guard.ts` â€” A Lit reactive controller or mixin that checks for a valid token on app load. If no token, shows a login screen with a "Sign in with GitHub" button. If token exists, validates it with a lightweight API call (`GET /user`) and proceeds to the app.
>
> 3. Create a login page component at `ui/src/pages/login-page.ts` with the GitHub sign-in button and Device Flow instructions (shows a user code, asks user to visit github.com/login/device).
>
> Document the required setup: user must create a GitHub OAuth App (or the project provides one) and set the Client ID in `.GITOPENCLAW/config/settings.json` under a new `pagesOAuthClientId` field. Note that the client_id is intentionally public (embedded in the static JS bundle) â€” this is safe for the Device Flow because the client_id alone cannot access any resources; only the user-authorized token (stored in `localStorage`) grants access.

---

### Task 2.5 â€” GitHub Pages Deployment Workflow

**Depends on:** Task 2.3 (Pages build), Task 2.4 (OAuth)

**AI Request:**

> Create a GitHub Actions workflow at `.github/workflows/gitopenclaw-pages-deploy.yml`:
>
> ```yaml
> name: Deploy GITOPENCLAW Dashboard to Pages
>
> on:
>   push:
>     paths:
>       - 'ui/**'
>       - '.GITOPENCLAW/config/**'
>   workflow_dispatch:
>
> permissions:
>   pages: write
>   id-token: write
>
> concurrency:
>   group: pages-deploy
>   cancel-in-progress: true
>
> jobs:
>   build-and-deploy:
>     runs-on: ubuntu-latest
>     environment:
>       name: github-pages
>       url: ${{ steps.deploy.outputs.page_url }}
>     steps:
>       - uses: actions/checkout@v4
>       - uses: actions/setup-node@v4
>         with:
>           node-version: '22'
>       - name: Install UI dependencies
>         run: cd ui && npm ci
>       - name: Build for GitHub Pages
>         run: cd ui && npm run build:pages
>         env:
>           GITHUB_REPOSITORY: ${{ github.repository }}
>           GITHUB_PAGES_BASE: /${{ github.event.repository.name }}/
>       - name: Upload Pages artifact
>         uses: actions/upload-pages-artifact@v3
>         with:
>           path: ui/dist-pages
>       - name: Deploy to Pages
>         id: deploy
>         uses: actions/deploy-pages@v4
> ```
>
> Also add a `workflow_dispatch` trigger input to the existing `GITOPENCLAW-WORKFLOW-AGENT.yml` workflow so the Pages app can trigger agent runs:
>
> ```yaml
> on:
>   issues:
>     types: [opened]
>   issue_comment:
>     types: [created]
>   workflow_dispatch:
>     inputs:
>       message:
>         description: 'Message to send to the agent'
>         required: true
>       issue_number:
>         description: 'Issue number to post the reply to'
>         required: true
> ```
>
> Update the agent orchestrator to handle `workflow_dispatch` events in addition to issue events.

---

### Task 2.6 â€” Chat View Backed by Issues API

**Depends on:** Task 2.2 (GitHub API adapter), Task 2.4 (OAuth)

**AI Request:**

> Create (or adapt an existing) Lit web component at `ui/src/pages/chat-page.ts` for the GitHub Pages deployment that provides a chat interface backed by GitHub Issues:
>
> 1. On load, list recent issues with agent conversations (issues that have comments from `github-actions[bot]`).
> 2. User selects an issue to view its conversation, displayed as a chat thread (user messages as right-aligned bubbles, agent replies as left-aligned).
> 3. A text input allows the user to post a new comment on the selected issue (via `GitHubApiAdapter.sendMessage`).
> 4. After posting, show a "thinking" indicator. Poll the issue's comments using exponential backoff (5s â†’ 10s â†’ 15s â†’ 20s â†’ 30s) for up to 3 minutes for the agent's reply. Use GitHub's conditional requests (ETag/If-None-Match headers) to avoid consuming rate limit on unchanged responses.
> 5. A "New Conversation" button creates a new issue with a user-provided title and first message.
> 6. Render markdown in agent replies (code blocks, tables, links, images).
>
> Use the `BackendAdapter` interface so the same component works with both the gateway and GitHub API backends. Add a loading skeleton for initial data fetch and error states for API failures.

---

## Phase 3: Auto-Morphing Pipeline (Month 2â€“3)

These tasks automate the generation of command registries and form UIs from source metadata.

### Task 3.1 â€” CLI Command Introspection & Registry Generation

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Create a build-time script at `scripts/generate-command-registry.ts` that:
>
> 1. Imports the Commander command definitions from `src/cli/` (the CLI entry point that registers all commands).
> 2. Walks the command tree, extracting for each command: name, description, aliases, arguments (with descriptions and defaults), options (with descriptions, types, and defaults), and parent command chain.
> 3. Outputs a machine-readable JSON registry at `.GITOPENCLAW/config/commands.json`:
>    ```json
>    {
>      "generatedAt": "2026-02-28T00:00:00Z",
>      "commands": [
>        {
>          "name": "config set",
>          "description": "Set a configuration value",
>          "arguments": [
>            { "name": "key", "description": "Configuration key", "required": true },
>            { "name": "value", "description": "Configuration value", "required": true }
>          ],
>          "options": [],
>          "category": "Configuration",
>          "trustLevel": "trusted"
>        }
>      ]
>    }
>    ```
> 4. Also generates a human-readable markdown reference at `.GITOPENCLAW/docs/COMMANDS.md` (replacing the static file from Task 1.2).
>
> Add a `generate:commands` script to the root `package.json`. Update the command parser (Task 1.1) to load from `commands.json` at runtime instead of a hardcoded list. This ensures the Issue Chat command surface stays in sync with the CLI automatically.

---

### Task 3.2 â€” Config Schema â†’ Form Auto-Generation for Pages UI

**Depends on:** Task 2.3 (Pages build), Task 0.1 (settings schema)

**AI Request:**

> Create a Lit web component at `ui/src/components/schema-form.ts` that renders a form from a JSON Schema:
>
> 1. Accepts a JSON Schema object and a data object as properties.
> 2. For each schema property, renders the appropriate form control: text input (string), number input (integer), select dropdown (enum), checkbox (boolean), nested fieldset (object), multi-select or tag input (array of strings).
> 3. Validates input against the schema in real-time (show inline validation errors).
> 4. Emits a `schema-form-submit` custom event with the updated data when the user saves.
>
> Create a configuration page at `ui/src/pages/config-page.ts` that:
> 1. Loads `.GITOPENCLAW/config/settings.schema.json` and `.GITOPENCLAW/config/settings.json` via the `BackendAdapter`.
> 2. Passes them to the `schema-form` component.
> 3. On submit, calls `adapter.patchConfig(updatedData)` to write the changes.
> 4. Shows a success/error toast notification.
>
> This makes every schema-validated config file automatically editable via the Pages UI without writing custom forms.

---

### Task 3.3 â€” One-Command Setup Script

**Depends on:** Task 2.5 (Pages deploy workflow), Phase 1 complete

**AI Request:**

> Create an installer script at `.GITOPENCLAW/install/setup.sh` (and a TypeScript equivalent `.GITOPENCLAW/install/GITOPENCLAW-INSTALLER.ts` updating the existing file) that automates the full setup for a new repository:
>
> 1. Verify the current directory is a git repository.
> 2. Copy the `.GITOPENCLAW/` directory structure (config, lifecycle scripts, state directory, docs, tests, package.json, enabled sentinel).
> 3. Copy the `.github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml` workflow file (and optionally the Pages deploy workflow).
> 4. Initialize `.GITOPENCLAW/state/` with `.gitignore` and empty subdirectories.
> 5. Prompt for (or accept as arguments): LLM provider, model, thinking level, GitHub username for trusted users.
> 6. Write `config/settings.json` with the provided values.
> 7. Run `cd .GITOPENCLAW && bun install` (or npm install).
> 8. Create an initial git commit with all the files.
> 9. Print next steps: "Add your API key as a GitHub Secret: `gh secret set ANTHROPIC_API_KEY`" and "Enable GitHub Pages in repo settings for the dashboard."
>
> The script should be runnable as: `curl -fsSL https://raw.githubusercontent.com/openclaw/openclaw/main/.GITOPENCLAW/install/setup.sh | bash`
>
> Update `.GITOPENCLAW/GITOPENCLAW-QUICKSTART.md` with instructions for both the manual "copy folder" approach and the automated installer.

---

## Phase 4: Observability & Resilience (Month 2â€“3)

### Task 4.1 â€” Structured Audit Trail (Run Manifests)

**Depends on:** Task 0.3 (cost/resource tracking)

**AI Request:**

> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, after the agent completes execution, emit a structured JSON run manifest to `.GITOPENCLAW/state/runs/<run-id>.json`:
>
> ```json
> {
>   "runId": "<github-run-id>",
>   "timestamp": "<ISO 8601>",
>   "trigger": {
>     "type": "issue_comment | issues | workflow_dispatch",
>     "issueNumber": 42,
>     "actor": "username"
>   },
>   "authorization": {
>     "trustLevel": "trusted | semi-trusted | untrusted",
>     "permissionLevel": "admin | maintain | write"
>   },
>   "config": {
>     "provider": "anthropic",
>     "model": "claude-opus-4-6",
>     "thinkingLevel": "high"
>   },
>   "execution": {
>     "durationMs": 45000,
>     "toolCalls": 12,
>     "tokensUsed": 28500,
>     "command": "agent | config | status | ..."
>   },
>   "session": {
>     "id": "session-xyz",
>     "turnNumber": 3
>   },
>   "outcome": "success | error | blocked",
>   "workflowRunUrl": "https://github.com/owner/repo/actions/runs/123456"
> }
> ```
>
> Create the `state/runs/` directory. Add it to the git add/commit step so manifests are persisted. Add a `.GITOPENCLAW/state/runs/.gitkeep` placeholder file.
>
> Create a helper function `buildRunManifest(context)` that collects all the fields. Make it testable by accepting a context object rather than reading environment variables directly. Add tests.

---

### Task 4.2 â€” Drift Detection and Health Check Workflow

**Depends on:** Task 0.1 (preflight/schema validation)

**AI Request:**

> Create a GitHub Actions workflow at `.github/workflows/gitopenclaw-health.yml`:
>
> ```yaml
> name: GITOPENCLAW Health Check
>
> on:
>   schedule:
>     - cron: '0 8 * * *'  # Daily at 08:00 UTC
>   push:
>     paths:
>       - '.GITOPENCLAW/**'
>   workflow_dispatch:
>
> permissions:
>   contents: read
>   issues: write
>
> jobs:
>   health-check:
>     runs-on: ubuntu-latest
>     timeout-minutes: 5
>     steps:
>       - uses: actions/checkout@v4
>       - uses: oven-sh/setup-bun@v2
>         with:
>           bun-version: latest
>       - name: Run health checks
>         run: bun .GITOPENCLAW/lifecycle/GITOPENCLAW-HEALTH.ts
>         env:
>           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
> ```
>
> Create `.GITOPENCLAW/lifecycle/GITOPENCLAW-HEALTH.ts` that performs:
>
> 1. **Structural integrity** â€” All required files exist (same checks as preflight).
> 2. **Config validity** â€” `settings.json` validates against schema.
> 3. **Workflow consistency** â€” Compute a hash of `GITOPENCLAW-WORKFLOW-AGENT.yml` and compare against a stored reference hash in `.GITOPENCLAW/config/workflow-reference.hash`. Report if they differ. Include instructions in the output for updating the reference hash when intentional changes are made: `sha256sum .github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml | cut -d' ' -f1 > .GITOPENCLAW/config/workflow-reference.hash`.
> 4. **State hygiene** â€” Scan `.GITOPENCLAW/state/` for files that shouldn't be there (no `.env` files, no files over 10MB, `.gitignore` is intact).
> 5. **Usage summary** â€” If `state/usage.log` exists, compute total token usage and cost estimate for the last 7 days.
>
> On any failure, open a GitHub issue titled "âš ï¸ GITOPENCLAW Health Check Failed" with the details (or update an existing open health issue). On all-clear, close any open health issues.
>
> Add tests for the health check logic.

---

## Phase 5: Multi-Entity Collaboration (Month 3+)

### Task 5.1 â€” Entity Identity Manifest

**Depends on:** Phase 4 complete

**AI Request:**

> Create `.GITOPENCLAW/config/entity.json`:
>
> ```json
> {
>   "entityId": "",
>   "agentName": "OpenClaw Agent",
>   "description": "AI assistant for this repository",
>   "capabilities": ["code-review", "documentation", "testing", "explain", "refactor"],
>   "trustTier": "semi-trusted",
>   "version": "1.0.0"
> }
> ```
>
> Add a companion schema at `.GITOPENCLAW/config/entity.schema.json`. The `entityId` should default to `"<owner>/<repo>"` and be auto-populated during setup (Task 3.3) or by the agent on first run.
>
> During the agent orchestrator startup (`.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`), if `entity.json` exists, include the entity identity in the system prompt context so the agent is aware of its own identity and capabilities.
>
> Add the entity manifest fields to the run manifest (Task 4.1) so audit trails include which entity produced each output.

---

### Task 5.2 â€” Cross-Repo Dispatch Handler

**Depends on:** Task 5.1 (entity identity)

**AI Request:**

> Add a `repository_dispatch` trigger to `.github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml`:
>
> ```yaml
> on:
>   issues:
>     types: [opened]
>   issue_comment:
>     types: [created]
>   repository_dispatch:
>     types: [gitopenclaw-request]
>   workflow_dispatch:
>     inputs:
>       message:
>         description: 'Message to send to the agent'
>         required: true
>       issue_number:
>         description: 'Issue number for the reply'
>         required: true
> ```
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, add handling for `repository_dispatch` events:
>
> 1. Extract the `client_payload` which should follow a structured envelope: `{ sender: { entityId, repo }, intent: string, payload: string, callbackIssue: number }`.
> 2. Validate the sender against a new `.GITOPENCLAW/config/collaboration-policy.json`:
>    ```json
>    {
>      "allowedSenders": [],
>      "allowedIntents": ["explain", "review", "document"],
>      "denyByDefault": true
>    }
>    ```
> 3. If the sender is allowed and the intent is permitted, execute the request.
> 4. Post the reply back to the sender's callback issue (requires a PAT with cross-repo scope or the sender must provide a callback URL).
>
> This enables agent-to-agent communication across repositories. Add the collaboration policy schema and validation to the preflight checks. Add tests.

---

### Task 5.3 â€” Collaboration Policy UI in Pages Dashboard

**Depends on:** Task 5.2 (dispatch handler), Task 3.2 (schema forms)

**AI Request:**

> Add a "Collaboration" page to the GitHub Pages dashboard at `ui/src/pages/collaboration-page.ts`:
>
> 1. Display the current entity identity from `config/entity.json` (read via `BackendAdapter`).
> 2. Render the collaboration policy from `config/collaboration-policy.json` using the schema-form component (Task 3.2).
> 3. Allow editing the `allowedSenders` list (add/remove entity IDs).
> 4. Allow editing the `allowedIntents` list.
> 5. Show a log of recent cross-repo requests from `state/runs/` manifests (filter by trigger type `repository_dispatch`).
> 6. Provide a "Test Dispatch" button that sends a test `repository_dispatch` event to a specified repo to verify connectivity.
>
> Add navigation to this page from the main dashboard sidebar.

---

## Summary: Execution Order

```
Phase 0 (Foundation â€” Security & Reliability)
  0.1  Settings Schema & Preflight Validation
  0.2  Trust-Level Gating
  0.3  Cost and Resource Boundaries

Phase 1 (Issue Chat Completeness)
  1.1  Slash Command Parser
  1.2  /help Command and Command Reference
  1.3  Rich Markdown Output Templates
  1.4  Machine-Readable Command Policy
  1.5  Onboarding Wizard via Multi-Turn Issue Thread

Phase 2 (GitHub Pages Dashboard)
  2.1  Backend Adapter Interface
  2.2  GitHub API Adapter
  2.3  Vite Build Configuration for Pages
  2.4  GitHub OAuth Authentication Flow
  2.5  GitHub Pages Deployment Workflow
  2.6  Chat View Backed by Issues API

Phase 3 (Auto-Morphing Pipeline)
  3.1  CLI Command Introspection & Registry Generation
  3.2  Config Schema â†’ Form Auto-Generation
  3.3  One-Command Setup Script

Phase 4 (Observability & Resilience)
  4.1  Structured Audit Trail (Run Manifests)
  4.2  Drift Detection and Health Check Workflow

Phase 5 (Multi-Entity Collaboration)
  5.1  Entity Identity Manifest
  5.2  Cross-Repo Dispatch Handler
  5.3  Collaboration Policy UI in Pages Dashboard
```

**Total: 16 tasks across 6 phases.**

Each AI request is self-contained and can be issued as-is to a coding agent. Tasks within a phase can be parallelized where dependencies allow (e.g., Tasks 1.2, 1.3, and 1.4 can run in parallel after Task 1.1 completes).

---

*Generated from `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md`, `.ANALYSIS-GIT-ENHANCEMENTS.md`, and `.ANALYSIS-GITHUB-VS-GIT.md`. See those documents for the full analysis and rationale behind each recommendation.*
