# CODEX: Make It Happen

Sequenced task list with exact AI requests to implement the full vision described in `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md`, informed by `.ANALYSIS-GIT-ENHANCEMENTS.md` and `.ANALYSIS-GITHUB-VS-GIT.md`.

Tasks are ordered by dependency chain â€” each task builds on the outputs of prior tasks. Within each phase, tasks are listed in execution order.

---

## Write Boundary Principle

> **All `.GITOPENCLAW` agent activity writes exclusively within the `.GITOPENCLAW/` directory tree. Source code outside `.GITOPENCLAW/` is read-only.**

This is the foundational invariant that makes `.GITOPENCLAW` safe to use in a fork: because the agent never modifies files outside its own folder, the fork can always `git pull` upstream changes from the parent repository with zero merge conflicts in source code.

### Rules

1. **Agent writes â†’ `.GITOPENCLAW/` only.** All runtime state (sessions, memory, issue mappings, run manifests, usage logs, config changes) lives inside `.GITOPENCLAW/state/` or `.GITOPENCLAW/config/`. The agent's `git add` is scoped to `.GITOPENCLAW/` exclusively.

2. **Installer is the sole exception.** The one-time `GITOPENCLAW-INSTALLER.ts` copies workflow files to `.github/workflows/` and issue templates to `.github/ISSUE_TEMPLATE/`. These are bootstrap artifacts â€” they are never modified by the agent at runtime. Workflow source-of-truth templates always live in `.GITOPENCLAW/install/` so the installer can be re-run after upstream updates.

3. **New workflows â†’ template-then-install pattern.** Any new GitHub Actions workflow introduced by a CODEX task must be authored as a template inside `.GITOPENCLAW/install/` and installed via the installer â€” never created directly in `.github/workflows/` by the agent or a task script.

4. **Dashboard and UI code â†’ `.GITOPENCLAW/dashboard/`.** The GitHub Pages dashboard is a self-contained app inside `.GITOPENCLAW/dashboard/`, not the repository's `ui/` source tree. This avoids entangling GITOPENCLAW's UI code with the OpenClaw product UI.

5. **Build/generation scripts â†’ `.GITOPENCLAW/scripts/`.** Any scripts that generate registries, schemas, or build artifacts for GITOPENCLAW live inside `.GITOPENCLAW/scripts/`, not the repository root `scripts/` directory.

6. **Read anything, write nothing (outside the boundary).** The agent's workspace is the full repository root â€” it can read, analyse, and reference any file in the source tree. But every file mutation (create, update, delete, `git add`) must target paths under `.GITOPENCLAW/`.

### Why this matters for fork upgradeability

```
upstream (openclaw/openclaw)          fork (your-org/your-repo)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€          â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
src/                                  src/               â† untouched by agent
docs/                                 docs/              â† untouched by agent
ui/                                   ui/                â† untouched by agent
.github/workflows/ci.yml              .github/workflows/ci.yml  â† untouched
                                      .GITOPENCLAW/      â† ALL agent writes here
                                      .github/workflows/GITOPENCLAW-*.yml â† installed once
```

Because the agent's writes are confined to `.GITOPENCLAW/` (which doesn't exist upstream), `git merge upstream/main` never produces conflicts from agent activity.

---

## State Cadence Bottlenecks

Multiple workflow runs can race when several issues or comments arrive in quick succession. The current push-retry loop (3 attempts with `--rebase`) handles simple cases, but higher cadence exposes bottlenecks:

### Identified bottlenecks

| Bottleneck | Trigger | Impact |
|---|---|---|
| **Push contention** | Two or more agent runs commit and push state changes to the default branch within seconds of each other | Rebase retries may exhaust; the losing run fails to persist state |
| **Session file collisions** | Two comments on the same issue trigger concurrent runs that both read/write the same session JSONL | Last-writer-wins; earlier turn's transcript may be lost |
| **Issue mapping races** | Concurrent runs for the same issue race to create/update `state/issues/<n>.json` | Stale mapping overwrites a newer one after rebase |
| **Memory log contention** | Concurrent runs both append to `state/memory.log` | `merge=union` git attribute mitigates this, but identical lines can be deduplicated |
| **GitHub API rate limits** | Burst of workflow runs each calling `gh api` for reactions, comments, permissions | 1000 requests/hour/token budget can be exhausted in a busy repo |

### Mitigation strategies (to be implemented in future tasks)

1. **GitHub Actions concurrency group.** Add `concurrency: { group: gitopenclaw-agent, cancel-in-progress: false }` to the workflow so runs are serialised. This is the simplest fix â€” each run waits for the prior one to finish, eliminating all push and file races. The trade-off is latency: the Nth concurrent trigger waits for N-1 prior runs.

2. **Per-issue concurrency groups.** Use `concurrency: { group: gitopenclaw-issue-${{ github.event.issue.number }}, cancel-in-progress: false }` to serialise runs per issue while allowing different issues to run in parallel. This balances throughput with safety â€” same-issue races are eliminated but cross-issue parallelism is preserved.

3. **Retry budget increase.** Increase the push retry limit from 3 to 5, and add exponential back-off (1s, 2s, 4s, 8s, 16s jitter) between attempts to reduce thundering-herd collisions.

4. **Atomic session updates.** Instead of read-modify-write on session files, use append-only writes with `>>` semantics. JSONL is already append-friendly; the copy-archive cycle should append new lines rather than overwrite the full file.

5. **Lock file protocol.** Before committing state, create a `.GITOPENCLAW/state/.lock` file with the workflow run ID. On conflict, the rebasing run checks whether the lock holder is still active (via Actions API) before retrying. Remove the lock on successful push.

6. **Rate-limit-aware API calls.** Wrap `gh` calls with retry-after handling: on HTTP 403/429, read the `X-RateLimit-Reset` header and sleep until the window resets rather than failing immediately.

---

## Phase 0: Foundation â€” Security & Reliability (Week 1â€“2)

These tasks harden the existing `.GITOPENCLAW/` prototype before adding new features. They have no external dependencies and unblock everything that follows.

### Task 0.1 â€” Settings Schema & Preflight Validation

**Why first:** Every subsequent task adds configuration surface. Validating config early prevents silent failures from compounding.

**AI Request:**

> Create a JSON Schema file at `.GITOPENCLAW/config/settings.schema.json` that validates the existing `settings.json` structure: `defaultProvider` (enum: "anthropic", "openai", "google", "bedrock", "ollama"), `defaultModel` (non-empty string), `defaultThinkingLevel` (enum: "none", "low", "medium", "high"). Then create a new lifecycle script `.GITOPENCLAW/lifecycle/GITOPENCLAW-PREFLIGHT.ts` that:
>
> 1. Validates `config/settings.json` against the schema (use Ajv or a lightweight inline validator).
> 2. Checks that all required files exist: `GITOPENCLAW-ENABLED.md`, `config/settings.json`, `lifecycle/GITOPENCLAW-AGENT.ts`, `lifecycle/GITOPENCLAW-ENABLED.ts`, `lifecycle/GITOPENCLAW-INDICATOR.ts`, `state/.gitignore`.
> 3. Verifies `state/.gitignore` contains entries that prevent accidental secret commits.
> 4. Exits non-zero with a descriptive error on any failure.
>
> Add this as a new step in both the workflow template (`.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-AGENT.yml`) and the installed copy (`.github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml`) between the "Guard" and "Preinstall" steps:
> ```yaml
>       - name: Preflight
>         run: bun .GITOPENCLAW/lifecycle/GITOPENCLAW-PREFLIGHT.ts
> ```
>
> Add Ajv (or chosen validator) to `.GITOPENCLAW/package.json` dependencies if needed. Update `.GITOPENCLAW/tests/phase0.test.js` to include structural assertions for the new schema file and preflight script.

---

### Task 0.2 â€” Trust-Level Gating

**Why second:** Must exist before slash commands (Task 1.1) so commands respect trust tiers from day one.

**AI Request:**

> Extend `.GITOPENCLAW/config/settings.json` and its schema (`.GITOPENCLAW/config/settings.schema.json`) with a new optional `trustPolicy` object:
>
> ```json
> {
>   "trustPolicy": {
>     "trustedUsers": [],
>     "semiTrustedRoles": ["write"],
>     "untrustedBehavior": "read-only-response"
>   }
> }
> ```
>
> Schema: `trustedUsers` is an array of GitHub usernames (strings). `semiTrustedRoles` is an array of GitHub permission levels (enum: "admin", "maintain", "write"). `untrustedBehavior` is enum: "read-only-response", "block".
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, add a trust-level resolution step after loading settings and before invoking the OpenClaw agent. The logic:
>
> 1. Read `github.actor` and their permission level from the workflow environment.
> 2. If the actor is in `trustedUsers` â†’ trust level is `trusted` (full capabilities).
> 3. Else if the actor's permission is in `semiTrustedRoles` â†’ trust level is `semi-trusted` (pass `--tools` flag to restrict to read-only tools: no bash, no file writes).
> 4. Else â†’ trust level is `untrusted` (respond with a read-only explanation or block based on `untrustedBehavior`).
>
> Export the trust resolution as a function so it can be unit-tested. Add tests in a new file `.GITOPENCLAW/tests/trust-level.test.js` covering all three tiers and edge cases (missing config, empty trustedUsers).

---

### Task 0.3 â€” Cost and Resource Boundaries

**Why third:** Sets guardrails before Task 1.1 opens up the full command surface.

**AI Request:**

> Extend `.GITOPENCLAW/config/settings.json` and its schema with a new optional `limits` object:
>
> ```json
> {
>   "limits": {
>     "maxTokensPerRun": 100000,
>     "maxToolCallsPerRun": 50,
>     "workflowTimeoutMinutes": 10
>   }
> }
> ```
>
> Schema: all three fields are positive integers; `maxTokensPerRun` minimum 1000, `maxToolCallsPerRun` minimum 1, `workflowTimeoutMinutes` minimum 1 maximum 360 (GitHub Actions supports up to 6 hours).
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, pass the `maxTokensPerRun` and `maxToolCallsPerRun` values as `--max-tokens` and `--max-tool-calls` flags (or equivalent environment variables) to the `openclaw agent` CLI invocation. After the agent completes, append a one-line JSON entry to `.GITOPENCLAW/state/usage.log` with: `timestamp`, `issueNumber`, `actor`, `tokensUsed` (from agent output), `toolCalls` (from agent output), `durationMs`. Set `merge=union` git attribute for `usage.log` in `.GITOPENCLAW/state/.gitattributes`.
>
> Validate in the preflight script (Task 0.1) that if `limits` is present, all values pass schema validation.

---

## Phase 1: Issue Chat Completeness (Week 3â€“4)

These tasks deliver the full CLI-equivalent command surface through GitHub Issue comments.

### Task 1.1 â€” Slash Command Parser

**Depends on:** Task 0.2 (trust gating), Task 0.3 (cost limits)

**AI Request:**

> Create a command parser module at `.GITOPENCLAW/lifecycle/command-parser.ts` that:
>
> 1. Accepts the raw text of an issue comment.
> 2. Detects if the first line starts with a `/` prefix (e.g., `/config set provider openai`, `/status`, `/help`, `/doctor`, `/channels status`, `/memory search query`, `/sessions list`, `/models list`, `/cron create`, `/plugins install`, `/update`, `/skills list`).
> 3. Parses the command name and arguments into a structured object: `{ command: string, args: string[], rawText: string }`.
> 4. If no `/` prefix is detected, returns `{ command: 'agent', args: [], rawText: <full comment body> }` (natural language mode â€” the existing behavior).
> 5. Exports a `parseCommand(text: string)` function and a `SUPPORTED_COMMANDS` constant listing all recognized commands with descriptions.
>
> Integrate into `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`:
> - Before invoking the agent, call `parseCommand(commentBody)`.
> - For structured commands (`/config`, `/status`, etc.), build the appropriate `openclaw <command> <args>` CLI invocation.
> - For natural language (`command === 'agent'`), use existing behavior.
> - Respect trust level from Task 0.2: semi-trusted users cannot execute mutation commands (`/config set`, `/plugins install`, `/update`).
>
> Add tests in `.GITOPENCLAW/tests/command-parser.test.js` covering: all supported commands, argument parsing, natural language fallback, unknown command handling, and trust-level gating of mutation commands.

---

### Task 1.2 â€” `/help` Command and Command Reference

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Add a `/help` command handler in the agent orchestrator (`.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`) that, when a user comments `/help` on an issue:
>
> 1. Does NOT invoke the OpenClaw agent.
> 2. Reads the `SUPPORTED_COMMANDS` list from the command parser (Task 1.1).
> 3. Posts a markdown-formatted issue comment listing all available commands with their descriptions, argument syntax, and examples. Group commands by category (Agent, Configuration, Channels, Sessions, Memory, Models, Cron, Health, Plugins, Skills).
> 4. Include a footer noting: "Commands prefixed with ğŸ”’ require trusted user access."
>
> Also generate a static reference file at `.GITOPENCLAW/docs/COMMANDS.md` containing the same information for documentation purposes.

---

### Task 1.3 â€” Rich Markdown Output Templates

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Create a module at `.GITOPENCLAW/lifecycle/output-templates.ts` that exports functions for rendering rich markdown output for structured commands:
>
> 1. `renderStatus(data)` â€” Renders a status dashboard table with agent runtime version, provider, model, memory entry count, session count, cron task count, plugin list. Uses emoji indicators (âœ…, âš ï¸, âŒ).
> 2. `renderChannelsStatus(channels)` â€” Renders a table of channel names, types, connection status.
> 3. `renderSessionsList(sessions)` â€” Renders a table of session IDs, issue numbers, turn counts, last activity timestamps.
> 4. `renderDoctorReport(checks)` â€” Renders a diagnostic report with pass/fail for each health check.
> 5. `renderConfigDiff(before, after)` â€” Renders a table showing changed configuration values.
> 6. `renderModelsList(models)` â€” Renders available models grouped by provider.
>
> Each function returns a markdown string ready to post as an issue comment. Use collapsible `<details>` sections for verbose output. Keep formatting consistent with the interaction pattern examples shown in `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md` Section 6.1.
>
> Add unit tests in `.GITOPENCLAW/tests/output-templates.test.js` verifying markdown structure for each template.

---

### Task 1.4 â€” Machine-Readable Command Policy

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> Create `.GITOPENCLAW/config/command-policy.json`:
>
> ```json
> {
>   "enforcement": "enforce",
>   "allowedCommands": ["help", "status", "doctor", "config", "channels", "sessions", "memory", "models", "cron", "plugins", "skills", "update", "agent"],
>   "blockedPatterns": ["deploy", "publish", "release", "delete", "rm -rf"],
>   "requirePrefixForActions": false,
>   "actionPrefix": "/openclaw"
> }
> ```
>
> Add a companion schema file `.GITOPENCLAW/config/command-policy.schema.json`.
>
> In the command parser (Task 1.1), after parsing the command, check it against the command policy:
> 1. If `enforcement` is `"enforce"` and the command is not in `allowedCommands`, reply with an error message and exit.
> 2. Scan the raw text for any `blockedPatterns` (substring match). If found, reply with a warning and exit.
> 3. If `requirePrefixForActions` is true, only process comments that start with the `actionPrefix`.
>
> Validate the command policy file in the preflight script (Task 0.1). Add tests.

---

### Task 1.5 â€” Onboarding Wizard via Multi-Turn Issue Thread

**Depends on:** Task 1.1 (command parser), Task 1.3 (output templates)

**AI Request:**

> Implement an onboarding flow triggered when a user creates an issue titled "Setup OpenClaw" or comments `/onboard` on any issue. In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`:
>
> 1. Detect the onboarding trigger (title match or `/onboard` command).
> 2. Check if onboarding has already been completed (look for a `.GITOPENCLAW/state/onboarded.json` marker file).
> 3. If not onboarded, track onboarding state in `.GITOPENCLAW/state/onboarding/<issueNumber>.json` with fields: `currentStep` (number), `responses` (object of stepâ†’value).
> 4. Post the appropriate step prompt as an issue comment:
>    - Step 1: "Choose your LLM provider" (anthropic, openai, google)
>    - Step 2: "Choose your model" (list options based on chosen provider)
>    - Step 3: "Set thinking level" (none, low, medium, high)
>    - Step 4: "Add any trusted users?" (comma-separated GitHub usernames or "skip")
> 5. When the user replies, detect the in-progress onboarding session, parse their response, advance to the next step.
> 6. After the final step, write the completed configuration to `config/settings.json`, create `state/onboarded.json`, and post a summary comment with the final config.
>
> Use the output templates from Task 1.3 for formatting. Add tests covering the full multi-step flow.

---

## Phase 2: GitHub Pages Dashboard (Week 5â€“8)

These tasks deliver the visual web dashboard at `owner.github.io/repo`.

> **âš ï¸ Write Boundary:** All dashboard code lives inside `.GITOPENCLAW/dashboard/` â€” a self-contained Lit/Vite app. No files are created or modified in the repository's `ui/` source tree. The dashboard reads source code (and the existing UI's adapter patterns) for reference but writes nothing outside `.GITOPENCLAW/`. This keeps the fork cleanly mergeable from upstream.

### Task 2.1 â€” Backend Adapter Interface

**Depends on:** Phase 1 complete (command surface exists)

**AI Request:**

> Create a new self-contained dashboard app at `.GITOPENCLAW/dashboard/`. Initialise it with a `package.json`, a Vite config, and a Lit entry point. The dashboard is independent of the repository's `ui/` â€” it does not import from or modify `ui/src/`.
>
> Create a backend adapter interface at `.GITOPENCLAW/dashboard/src/adapters/backend.ts`:
>
> ```typescript
> export interface BackendAdapter {
>   // Chat
>   sendMessage(sessionId: string, message: string): Promise<AgentReply>
>   getMessages(sessionId: string): Promise<Message[]>
>   // Config
>   getConfig(): Promise<Record<string, unknown>>
>   patchConfig(patch: Record<string, unknown>): Promise<void>
>   // Sessions
>   listSessions(): Promise<SessionSummary[]>
>   getSession(id: string): Promise<SessionTranscript>
>   // Memory
>   searchMemory(query: string): Promise<MemoryResult[]>
>   // Channels
>   getChannelStatus(): Promise<ChannelStatus[]>
>   // Actions
>   triggerWorkflow(inputs: Record<string, string>): Promise<WorkflowRun>
>   getWorkflowLogs(runId: number): Promise<string>
> }
> ```
>
> Define the type interfaces for `AgentReply`, `Message`, `SessionSummary`, `SessionTranscript`, `MemoryResult`, `ChannelStatus`, and `WorkflowRun`. Export the interface and types.
>
> Create `.GITOPENCLAW/dashboard/src/adapters/gateway-adapter.ts` that implements `BackendAdapter` by wrapping WebSocket RPC calls (referencing the patterns in `ui/src/ui/gateway.ts` for inspiration, but without importing from it).
>
> Do NOT create the GitHub API adapter yet (that is Task 2.2). The goal here is to establish the interface so both adapters share the same contract.

---

### Task 2.2 â€” GitHub API Adapter

**Depends on:** Task 2.1 (adapter interface)

**AI Request:**

> Create `.GITOPENCLAW/dashboard/src/adapters/github-api-adapter.ts` that implements the `BackendAdapter` interface from Task 2.1 using the GitHub REST API (via `@octokit/rest` or raw `fetch` calls with the user's OAuth token):
>
> 1. `sendMessage(sessionId, message)` â€” Creates a new comment on the issue associated with the session (looks up issue number from `.GITOPENCLAW/state/issues/` via Contents API). Returns a pending `AgentReply` (the actual reply arrives asynchronously via the workflow).
> 2. `getMessages(sessionId)` â€” Reads the JSONL session transcript from `.GITOPENCLAW/state/sessions/<id>.jsonl` via Contents API. Parses and returns as `Message[]`.
> 3. `getConfig()` â€” Reads `.GITOPENCLAW/config/settings.json` via Contents API.
> 4. `patchConfig(patch)` â€” Reads current config, merges the patch, commits the updated file via Commits API (creates a commit on the default branch). **Note:** the commit targets only `.GITOPENCLAW/config/settings.json` â€” no source files are touched.
> 5. `listSessions()` â€” Lists the `.GITOPENCLAW/state/sessions/` directory via Contents API. Returns file names and metadata.
> 6. `getSession(id)` â€” Reads and parses a specific JSONL transcript.
> 7. `searchMemory(query)` â€” Triggers a `workflow_dispatch` event with the search query as an input. Returns a placeholder; results are fetched from workflow artifacts on completion.
> 8. `getChannelStatus()` â€” Reads last workflow run status and any committed channel state files.
> 9. `triggerWorkflow(inputs)` â€” Triggers a `workflow_dispatch` on the agent workflow.
> 10. `getWorkflowLogs(runId)` â€” Fetches workflow run logs via Actions API.
>
> Store the OAuth token in `localStorage` (set during the OAuth flow in Task 2.4). Store the repository owner/name from the build-time `__GITHUB_REPO__` define. Add `@octokit/rest` to `.GITOPENCLAW/dashboard/package.json` dependencies if used.

---

### Task 2.3 â€” Vite Build Configuration for GitHub Pages

**Depends on:** Task 2.2 (GitHub API adapter)

**AI Request:**

> Create a Vite config file at `.GITOPENCLAW/dashboard/vite.config.ts` for building the dashboard as a GitHub Pages static site:
>
> ```typescript
> import { defineConfig } from 'vite'
>
> export default defineConfig({
>   base: process.env.GITHUB_PAGES_BASE || '/',
>   define: {
>     __BACKEND_MODE__: JSON.stringify('github-api'),
>     __GITHUB_REPO__: JSON.stringify(process.env.GITHUB_REPOSITORY || ''),
>   },
>   build: {
>     outDir: 'dist',
>   },
> })
> ```
>
> In the dashboard app's initialization code (`.GITOPENCLAW/dashboard/src/index.ts`), add backend mode detection:
>
> ```typescript
> declare const __BACKEND_MODE__: string
> declare const __GITHUB_REPO__: string
>
> const adapter = __BACKEND_MODE__ === 'github-api'
>   ? new GitHubApiAdapter(__GITHUB_REPO__)
>   : new GatewayAdapter()
> ```
>
> Add a `build` script to `.GITOPENCLAW/dashboard/package.json`:
> ```json
> "build": "vite build"
> ```
>
> Ensure the build produces a complete static site in `.GITOPENCLAW/dashboard/dist/` including `index.html`, all JS/CSS assets, and any static assets. Add `.GITOPENCLAW/dashboard/dist/` to `.GITOPENCLAW/dashboard/.gitignore`.
>
> **Write Boundary:** The Vite config, package.json, and all source/build output live entirely within `.GITOPENCLAW/dashboard/`. No files in `ui/` are created or modified.

---

### Task 2.4 â€” GitHub OAuth Authentication Flow

**Depends on:** Task 2.3 (Pages build config)

**AI Request:**

> Create an OAuth authentication flow for the GitHub Pages dashboard. In `.GITOPENCLAW/dashboard/src/auth/`:
>
> 1. `github-oauth.ts` â€” Implements the GitHub OAuth web application flow:
>    - `startOAuthFlow()` â€” Redirects to `https://github.com/login/oauth/authorize` with `client_id`, `redirect_uri` (the Pages URL), and `scope` (repo, read:user).
>    - `handleOAuthCallback()` â€” Extracts the `code` from the URL query string after redirect. Exchanges it for an access token. Note: The code-to-token exchange requires a server-side step (GitHub does not support CORS for the token endpoint). Options: (a) use a lightweight serverless function (Cloudflare Worker, Vercel function) as a proxy, or (b) use a GitHub OAuth App with the Device Flow (which is fully client-side). Implement option (b) â€” the Device Flow.
>    - `getStoredToken()` â€” Reads the OAuth token from `localStorage`.
>    - `clearToken()` â€” Removes the token and redirects to login.
>
> 2. `auth-guard.ts` â€” A Lit reactive controller or mixin that checks for a valid token on app load. If no token, shows a login screen with a "Sign in with GitHub" button. If token exists, validates it with a lightweight API call (`GET /user`) and proceeds to the app.
>
> 3. Create a login page component at `.GITOPENCLAW/dashboard/src/pages/login-page.ts` with the GitHub sign-in button and Device Flow instructions (shows a user code, asks user to visit github.com/login/device).
>
> Document the required setup: user must create a GitHub OAuth App (or the project provides one) and set the Client ID in `.GITOPENCLAW/config/settings.json` under a new `pagesOAuthClientId` field. Note that the client_id is intentionally public (embedded in the static JS bundle) â€” this is safe for the Device Flow because the client_id alone cannot access any resources; only the user-authorized token (stored in `localStorage`) grants access.

---

### Task 2.5 â€” GitHub Pages Deployment Workflow

**Depends on:** Task 2.3 (Pages build), Task 2.4 (OAuth)

**AI Request:**

> **Write Boundary:** The workflow template is authored at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-PAGES.yml` and installed to `.github/workflows/` by the installer (Task 3.3). The agent never creates workflow files directly.
>
> Create a workflow template at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-PAGES.yml`:
>
> ```yaml
> name: Deploy GITOPENCLAW Dashboard to Pages
>
> on:
>   push:
>     paths:
>       - '.GITOPENCLAW/dashboard/**'
>       - '.GITOPENCLAW/config/**'
>   workflow_dispatch:
>
> permissions:
>   pages: write
>   id-token: write
>
> concurrency:
>   group: pages-deploy
>   cancel-in-progress: true
>
> jobs:
>   build-and-deploy:
>     runs-on: ubuntu-latest
>     environment:
>       name: github-pages
>       url: ${{ steps.deploy.outputs.page_url }}
>     steps:
>       - uses: actions/checkout@v4
>       - uses: actions/setup-node@v4
>         with:
>           node-version: '22'
>       - name: Install dashboard dependencies
>         run: cd .GITOPENCLAW/dashboard && npm ci
>       - name: Build for GitHub Pages
>         run: cd .GITOPENCLAW/dashboard && npm run build
>         env:
>           GITHUB_REPOSITORY: ${{ github.repository }}
>           GITHUB_PAGES_BASE: /${{ github.event.repository.name }}/
>       - name: Upload Pages artifact
>         uses: actions/upload-pages-artifact@v3
>         with:
>           path: .GITOPENCLAW/dashboard/dist
>       - name: Deploy to Pages
>         id: deploy
>         uses: actions/deploy-pages@v4
> ```
>
> Update `GITOPENCLAW-INSTALLER.ts` (Task 3.3) to copy this template to `.github/workflows/GITOPENCLAW-WORKFLOW-PAGES.yml` during installation.
>
> Also add a `workflow_dispatch` trigger input to the agent workflow **template** (`.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-AGENT.yml`) so the Pages app can trigger agent runs:
>
> ```yaml
> on:
>   issues:
>     types: [opened]
>   issue_comment:
>     types: [created]
>   workflow_dispatch:
>     inputs:
>       message:
>         description: 'Message to send to the agent'
>         required: true
>       issue_number:
>         description: 'Issue number to post the reply to'
>         required: true
> ```
>
> Update the agent orchestrator to handle `workflow_dispatch` events in addition to issue events.

---

### Task 2.6 â€” Chat View Backed by Issues API

**Depends on:** Task 2.2 (GitHub API adapter), Task 2.4 (OAuth)

**AI Request:**

> Create a Lit web component at `.GITOPENCLAW/dashboard/src/pages/chat-page.ts` for the GitHub Pages deployment that provides a chat interface backed by GitHub Issues:
>
> 1. On load, list recent issues with agent conversations (issues that have comments from `github-actions[bot]`).
> 2. User selects an issue to view its conversation, displayed as a chat thread (user messages as right-aligned bubbles, agent replies as left-aligned).
> 3. A text input allows the user to post a new comment on the selected issue (via `GitHubApiAdapter.sendMessage`).
> 4. After posting, show a "thinking" indicator. Poll the issue's comments using exponential backoff (5s â†’ 10s â†’ 15s â†’ 20s â†’ 30s) for up to 3 minutes for the agent's reply. Use GitHub's conditional requests (ETag/If-None-Match headers) to avoid consuming rate limit on unchanged responses.
> 5. A "New Conversation" button creates a new issue with a user-provided title and first message.
> 6. Render markdown in agent replies (code blocks, tables, links, images).
>
> Use the `BackendAdapter` interface so the same component works with both the gateway and GitHub API backends. Add a loading skeleton for initial data fetch and error states for API failures.

---

## Phase 3: Auto-Morphing Pipeline (Month 2â€“3)

These tasks automate the generation of command registries and form UIs from source metadata.

### Task 3.1 â€” CLI Command Introspection & Registry Generation

**Depends on:** Task 1.1 (command parser)

**AI Request:**

> **Write Boundary:** The generation script lives inside `.GITOPENCLAW/scripts/` (not the repository root `scripts/`), and all output files land inside `.GITOPENCLAW/`. The script *reads* the Commander command definitions from `src/cli/` but writes only to `.GITOPENCLAW/config/` and `.GITOPENCLAW/docs/`.
>
> Create a build-time script at `.GITOPENCLAW/scripts/generate-command-registry.ts` that:
>
> 1. Imports (or dynamically reads) the Commander command definitions from `src/cli/` (the CLI entry point that registers all commands).
> 2. Walks the command tree, extracting for each command: name, description, aliases, arguments (with descriptions and defaults), options (with descriptions, types, and defaults), and parent command chain.
> 3. Outputs a machine-readable JSON registry at `.GITOPENCLAW/config/commands.json`:
>    ```json
>    {
>      "generatedAt": "2026-02-28T00:00:00Z",
>      "commands": [
>        {
>          "name": "config set",
>          "description": "Set a configuration value",
>          "arguments": [
>            { "name": "key", "description": "Configuration key", "required": true },
>            { "name": "value", "description": "Configuration value", "required": true }
>          ],
>          "options": [],
>          "category": "Configuration",
>          "trustLevel": "trusted"
>        }
>      ]
>    }
>    ```
> 4. Also generates a human-readable markdown reference at `.GITOPENCLAW/docs/COMMANDS.md` (replacing the static file from Task 1.2).
>
> Add a `generate:commands` script to `.GITOPENCLAW/package.json` (not the root `package.json`). Update the command parser (Task 1.1) to load from `commands.json` at runtime instead of a hardcoded list. This ensures the Issue Chat command surface stays in sync with the CLI automatically.

---

### Task 3.2 â€” Config Schema â†’ Form Auto-Generation for Pages UI

**Depends on:** Task 2.3 (Pages build), Task 0.1 (settings schema)

**AI Request:**

> Create a Lit web component at `.GITOPENCLAW/dashboard/src/components/schema-form.ts` that renders a form from a JSON Schema:
>
> 1. Accepts a JSON Schema object and a data object as properties.
> 2. For each schema property, renders the appropriate form control: text input (string), number input (integer), select dropdown (enum), checkbox (boolean), nested fieldset (object), multi-select or tag input (array of strings).
> 3. Validates input against the schema in real-time (show inline validation errors).
> 4. Emits a `schema-form-submit` custom event with the updated data when the user saves.
>
> Create a configuration page at `.GITOPENCLAW/dashboard/src/pages/config-page.ts` that:
> 1. Loads `.GITOPENCLAW/config/settings.schema.json` and `.GITOPENCLAW/config/settings.json` via the `BackendAdapter`.
> 2. Passes them to the `schema-form` component.
> 3. On submit, calls `adapter.patchConfig(updatedData)` to write the changes. **Note:** `patchConfig` writes only to `.GITOPENCLAW/config/settings.json` â€” no source files are touched.
> 4. Shows a success/error toast notification.
>
> This makes every schema-validated config file automatically editable via the Pages UI without writing custom forms.

---

### Task 3.3 â€” One-Command Setup Script

**Depends on:** Task 2.5 (Pages deploy workflow), Phase 1 complete

**AI Request:**

> Create an installer script at `.GITOPENCLAW/install/setup.sh` (and a TypeScript equivalent `.GITOPENCLAW/install/GITOPENCLAW-INSTALLER.ts` updating the existing file) that automates the full setup for a new repository:
>
> 1. Verify the current directory is a git repository.
> 2. Copy the `.GITOPENCLAW/` directory structure (config, lifecycle scripts, state directory, docs, tests, package.json, enabled sentinel).
> 3. Copy workflow templates from `.GITOPENCLAW/install/` to `.github/workflows/`:
>    - `GITOPENCLAW-WORKFLOW-AGENT.yml` (agent workflow)
>    - `GITOPENCLAW-WORKFLOW-PAGES.yml` (Pages deploy, optional)
>    - `GITOPENCLAW-WORKFLOW-HEALTH.yml` (health check, optional â€” from Task 4.2)
>    This is the **only place** files are written outside `.GITOPENCLAW/` â€” the installer is the sole sanctioned boundary-crossing write point.
> 4. Initialize `.GITOPENCLAW/state/` with `.gitignore` and empty subdirectories.
> 5. Prompt for (or accept as arguments): LLM provider, model, thinking level, GitHub username for trusted users.
> 6. Write `config/settings.json` with the provided values.
> 7. Run `cd .GITOPENCLAW && bun install` (or npm install).
> 8. Create an initial git commit with all the files.
> 9. Print next steps: "Add your API key as a GitHub Secret: `gh secret set ANTHROPIC_API_KEY`" and "Enable GitHub Pages in repo settings for the dashboard."
>
> The script should be runnable as: `curl -fsSL https://raw.githubusercontent.com/openclaw/openclaw/main/.GITOPENCLAW/install/setup.sh | bash`
>
> Update `.GITOPENCLAW/GITOPENCLAW-QUICKSTART.md` with instructions for both the manual "copy folder" approach and the automated installer.

---

## Phase 4: Observability & Resilience (Month 2â€“3)

### Task 4.1 â€” Structured Audit Trail (Run Manifests)

**Depends on:** Task 0.3 (cost/resource tracking)

**AI Request:**

> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, after the agent completes execution, emit a structured JSON run manifest to `.GITOPENCLAW/state/runs/<run-id>.json`:
>
> ```json
> {
>   "runId": "<github-run-id>",
>   "timestamp": "<ISO 8601>",
>   "trigger": {
>     "type": "issue_comment | issues | workflow_dispatch",
>     "issueNumber": 42,
>     "actor": "username"
>   },
>   "authorization": {
>     "trustLevel": "trusted | semi-trusted | untrusted",
>     "permissionLevel": "admin | maintain | write"
>   },
>   "config": {
>     "provider": "anthropic",
>     "model": "claude-opus-4-6",
>     "thinkingLevel": "high"
>   },
>   "execution": {
>     "durationMs": 45000,
>     "toolCalls": 12,
>     "tokensUsed": 28500,
>     "command": "agent | config | status | ..."
>   },
>   "session": {
>     "id": "session-xyz",
>     "turnNumber": 3
>   },
>   "outcome": "success | error | blocked",
>   "workflowRunUrl": "https://github.com/owner/repo/actions/runs/123456"
> }
> ```
>
> Create the `state/runs/` directory. Add it to the git add/commit step so manifests are persisted. Add a `.GITOPENCLAW/state/runs/.gitkeep` placeholder file.
>
> Create a helper function `buildRunManifest(context)` that collects all the fields. Make it testable by accepting a context object rather than reading environment variables directly. Add tests.

---

### Task 4.2 â€” Drift Detection and Health Check Workflow

**Depends on:** Task 0.1 (preflight/schema validation)

**AI Request:**

> **Write Boundary:** The workflow template is authored at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-HEALTH.yml` and installed to `.github/workflows/` by the installer (Task 3.3). The health check script itself lives inside `.GITOPENCLAW/lifecycle/` and writes only to `.GITOPENCLAW/state/` (if applicable).
>
> Create a workflow template at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-HEALTH.yml`:
>
> ```yaml
> name: GITOPENCLAW Health Check
>
> on:
>   schedule:
>     - cron: '0 8 * * *'  # Daily at 08:00 UTC
>   push:
>     paths:
>       - '.GITOPENCLAW/**'
>   workflow_dispatch:
>
> permissions:
>   contents: read
>   issues: write
>
> jobs:
>   health-check:
>     runs-on: ubuntu-latest
>     timeout-minutes: 5
>     steps:
>       - uses: actions/checkout@v4
>       - uses: oven-sh/setup-bun@v2
>         with:
>           bun-version: latest
>       - name: Run health checks
>         run: bun .GITOPENCLAW/lifecycle/GITOPENCLAW-HEALTH.ts
>         env:
>           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
> ```
>
> Update `GITOPENCLAW-INSTALLER.ts` to copy this template to `.github/workflows/GITOPENCLAW-WORKFLOW-HEALTH.yml` during installation.
>
> Create `.GITOPENCLAW/lifecycle/GITOPENCLAW-HEALTH.ts` that performs:
>
> 1. **Structural integrity** â€” All required files exist (same checks as preflight).
> 2. **Config validity** â€” `settings.json` validates against schema.
> 3. **Workflow consistency** â€” Compute a hash of the installed workflow at `.github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml` and compare against a stored reference hash in `.GITOPENCLAW/config/workflow-reference.hash`. Report if they differ. Include instructions in the output for updating the reference hash when intentional changes are made: `sha256sum .github/workflows/GITOPENCLAW-WORKFLOW-AGENT.yml | cut -d' ' -f1 > .GITOPENCLAW/config/workflow-reference.hash`.
> 4. **State hygiene** â€” Scan `.GITOPENCLAW/state/` for files that shouldn't be there (no `.env` files, no files over 10MB, `.gitignore` is intact).
> 5. **Usage summary** â€” If `state/usage.log` exists, compute total token usage and cost estimate for the last 7 days.
> 6. **Write boundary audit** â€” Verify that the most recent agent commits (from `gitopenclaw[bot]`) only modified files under `.GITOPENCLAW/`. Flag any commits that touched files outside the boundary as a violation.
>
> On any failure, open a GitHub issue titled "âš ï¸ GITOPENCLAW Health Check Failed" with the details (or update an existing open health issue). On all-clear, close any open health issues.
>
> Add tests for the health check logic.

---

## Phase 5: Multi-Entity Collaboration (Month 3+)

### Task 5.1 â€” Entity Identity Manifest

**Depends on:** Phase 4 complete

**AI Request:**

> Create `.GITOPENCLAW/config/entity.json`:
>
> ```json
> {
>   "entityId": "",
>   "agentName": "OpenClaw Agent",
>   "description": "AI assistant for this repository",
>   "capabilities": ["code-review", "documentation", "testing", "explain", "refactor"],
>   "trustTier": "semi-trusted",
>   "version": "1.0.0"
> }
> ```
>
> Add a companion schema at `.GITOPENCLAW/config/entity.schema.json`. The `entityId` should default to `"<owner>/<repo>"` and be auto-populated during setup (Task 3.3) or by the agent on first run.
>
> During the agent orchestrator startup (`.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`), if `entity.json` exists, include the entity identity in the system prompt context so the agent is aware of its own identity and capabilities.
>
> Add the entity manifest fields to the run manifest (Task 4.1) so audit trails include which entity produced each output.

---

### Task 5.2 â€” Cross-Repo Dispatch Handler

**Depends on:** Task 5.1 (entity identity)

**AI Request:**

> **Write Boundary:** The trigger change is made to the workflow **template** at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-AGENT.yml`. After updating the template, the installer must be re-run on deployed forks to propagate the change to `.github/workflows/`. The agent orchestrator changes are confined to `.GITOPENCLAW/lifecycle/`.
>
> Add a `repository_dispatch` trigger to the workflow template at `.GITOPENCLAW/install/GITOPENCLAW-WORKFLOW-AGENT.yml`:
>
> ```yaml
> on:
>   issues:
>     types: [opened]
>   issue_comment:
>     types: [created]
>   repository_dispatch:
>     types: [gitopenclaw-request]
>   workflow_dispatch:
>     inputs:
>       message:
>         description: 'Message to send to the agent'
>         required: true
>       issue_number:
>         description: 'Issue number for the reply'
>         required: true
> ```
>
> In `.GITOPENCLAW/lifecycle/GITOPENCLAW-AGENT.ts`, add handling for `repository_dispatch` events:
>
> 1. Extract the `client_payload` which should follow a structured envelope: `{ sender: { entityId, repo }, intent: string, payload: string, callbackIssue: number }`.
> 2. Validate the sender against a new `.GITOPENCLAW/config/collaboration-policy.json`:
>    ```json
>    {
>      "allowedSenders": [],
>      "allowedIntents": ["explain", "review", "document"],
>      "denyByDefault": true
>    }
>    ```
> 3. If the sender is allowed and the intent is permitted, execute the request.
> 4. Post the reply back to the sender's callback issue (requires a PAT with cross-repo scope or the sender must provide a callback URL).
>
> This enables agent-to-agent communication across repositories. Add the collaboration policy schema and validation to the preflight checks. Add tests.

---

### Task 5.3 â€” Collaboration Policy UI in Pages Dashboard

**Depends on:** Task 5.2 (dispatch handler), Task 3.2 (schema forms)

**AI Request:**

> Add a "Collaboration" page to the GitHub Pages dashboard at `.GITOPENCLAW/dashboard/src/pages/collaboration-page.ts`:
>
> 1. Display the current entity identity from `config/entity.json` (read via `BackendAdapter`).
> 2. Render the collaboration policy from `config/collaboration-policy.json` using the schema-form component (Task 3.2).
> 3. Allow editing the `allowedSenders` list (add/remove entity IDs).
> 4. Allow editing the `allowedIntents` list.
> 5. Show a log of recent cross-repo requests from `state/runs/` manifests (filter by trigger type `repository_dispatch`).
> 6. Provide a "Test Dispatch" button that sends a test `repository_dispatch` event to a specified repo to verify connectivity.
>
> Add navigation to this page from the main dashboard sidebar.

---

## Summary: Execution Order

```
Phase 0 (Foundation â€” Security & Reliability)                     writes â†’ .GITOPENCLAW/ only
  0.1  Settings Schema & Preflight Validation                       âœ… boundary-safe
  0.2  Trust-Level Gating                                           âœ… boundary-safe
  0.3  Cost and Resource Boundaries                                 âœ… boundary-safe

Phase 1 (Issue Chat Completeness)                                 writes â†’ .GITOPENCLAW/ only
  1.1  Slash Command Parser                                         âœ… boundary-safe
  1.2  /help Command and Command Reference                          âœ… boundary-safe
  1.3  Rich Markdown Output Templates                               âœ… boundary-safe
  1.4  Machine-Readable Command Policy                              âœ… boundary-safe
  1.5  Onboarding Wizard via Multi-Turn Issue Thread                âœ… boundary-safe

Phase 2 (GitHub Pages Dashboard)                                  writes â†’ .GITOPENCLAW/dashboard/
  2.1  Backend Adapter Interface                                    âœ… .GITOPENCLAW/dashboard/
  2.2  GitHub API Adapter                                           âœ… .GITOPENCLAW/dashboard/
  2.3  Vite Build Configuration for Pages                           âœ… .GITOPENCLAW/dashboard/
  2.4  GitHub OAuth Authentication Flow                             âœ… .GITOPENCLAW/dashboard/
  2.5  GitHub Pages Deployment Workflow                              âš™ï¸ template in .GITOPENCLAW/install/
  2.6  Chat View Backed by Issues API                               âœ… .GITOPENCLAW/dashboard/

Phase 3 (Auto-Morphing Pipeline)                                  writes â†’ .GITOPENCLAW/ only
  3.1  CLI Command Introspection & Registry Generation              âœ… .GITOPENCLAW/scripts/ â†’ .GITOPENCLAW/config/
  3.2  Config Schema â†’ Form Auto-Generation                         âœ… .GITOPENCLAW/dashboard/
  3.3  One-Command Setup Script (installer)                         âš™ï¸ sole sanctioned boundary-crossing write

Phase 4 (Observability & Resilience)                              writes â†’ .GITOPENCLAW/ only
  4.1  Structured Audit Trail (Run Manifests)                       âœ… boundary-safe
  4.2  Drift Detection and Health Check Workflow                    âš™ï¸ template in .GITOPENCLAW/install/

Phase 5 (Multi-Entity Collaboration)                              writes â†’ .GITOPENCLAW/ only
  5.1  Entity Identity Manifest                                     âœ… boundary-safe
  5.2  Cross-Repo Dispatch Handler                                  âš™ï¸ template in .GITOPENCLAW/install/
  5.3  Collaboration Policy UI in Pages Dashboard                   âœ… .GITOPENCLAW/dashboard/
```

Legend: âœ… = writes only within `.GITOPENCLAW/`; âš™ï¸ = template-then-install pattern (installer copies to `.github/`).

**Total: 16 tasks across 6 phases.**

Every task respects the Write Boundary Principle. Tasks marked âš™ï¸ use the template-then-install pattern: source-of-truth lives in `.GITOPENCLAW/install/`, and the installer (Task 3.3) is the sole sanctioned mechanism for writing files outside `.GITOPENCLAW/`.

Each AI request is self-contained and can be issued as-is to a coding agent. Tasks within a phase can be parallelized where dependencies allow (e.g., Tasks 1.2, 1.3, and 1.4 can run in parallel after Task 1.1 completes).

---

*Generated from `.ANALYSIS-OPENCLAW-FUNCTIONALITY-EQUIVALENTS.md`, `.ANALYSIS-GIT-ENHANCEMENTS.md`, and `.ANALYSIS-GITHUB-VS-GIT.md`. See those documents for the full analysis and rationale behind each recommendation.*
