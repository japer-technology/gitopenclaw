# Analysis: `.GITHUB-MODE` vs `.GITOPENCLAW`

A deep comparative analysis of the two OpenClaw-on-GitHub execution models in this repository.

---

## Executive Summary

`.GITHUB-MODE` and `.GITOPENCLAW` both aim to run OpenClaw inside GitHub, but they solve fundamentally different problems and target different audiences.

| Dimension | `.GITHUB-MODE` | `.GITOPENCLAW` |
|-----------|---------------|----------------|
| **Core thesis** | GitHub as a governed runtime plane for team-scale automation | GitHub as a zero-infrastructure AI agent host |
| **Primary audience** | Maintainer teams operating OpenClaw at scale | Any developer who wants an AI agent in their repo |
| **Interaction model** | Command/event-driven workflows with approval gates | Conversational via GitHub Issues |
| **Complexity** | 23 workflows, 25 scripts, 19 test files, 23 runtime contracts | 1 workflow, 3 lifecycle scripts, 1 test file |
| **Time to value** | Days/weeks (governance contracts must be configured) | 5 minutes (copy folder, push, open issue) |
| **Design philosophy** | Contract-first, fail-closed governance | Simplicity-first, drop-in operation |

---

## 1. What Each System Is Trying to Achieve

### `.GITHUB-MODE`: GitHub as a Governed Runtime Plane

`.GITHUB-MODE` reframes GitHub from a passive code host into an **active infrastructure participant**. Its central thesis:

> One capability model, two interaction loops. The installed runtime handles synchronous, interactive, device-coupled work. GitHub Mode handles asynchronous, command/event-driven, auditable, team-reviewed automation.

The goal is **capability parity** between the locally installed OpenClaw runtime and a GitHub-hosted execution plane‚Äîsame agents, routing, tool policy, and model providers‚Äîwhile accepting intentionally different interaction models. The installed runtime is conversational and immediate; GitHub Mode is event-driven, approval-gated, and fully auditable.

Key objectives:
- Run the real OpenClaw runtime engine (from `src/`) inside GitHub Actions
- Layer machine-readable governance contracts over every execution path
- Enforce trust tiers (untrusted fork ‚Üí semi-trusted internal ‚Üí trusted maintainer)
- Produce tamper-evident attestations for every automation output
- Enable team-scale command-driven automation (e.g., `/openclaw explain this PR`)
- Gate promotions (dev ‚Üí staging ‚Üí prod) behind validated checks and approvals

### `.GITOPENCLAW`: GitHub as Zero-Infrastructure AI Agent Host

`.GITOPENCLAW` starts from a radical simplicity insight:

> GitHub is already the complete infrastructure for an AI agent. Every repo has compute (Actions), storage (git), secrets management, access control, webhooks, and a user interface (Issues & PRs). Use what you already paid for.

The goal is to make deploying an AI agent as simple as **copying a folder into any repository**. No SaaS dashboards, no databases, no webhook receivers, no billing complexity. The elevator pitch: *Drop a folder. Push. Open an issue. Something answers.*

Key objectives:
- Zero external infrastructure (GitHub provides everything)
- 5-minute setup with a single `bun install` and one secret
- Multi-turn conversations via GitHub Issues with persistent memory
- Full OpenClaw runtime (30+ tools, semantic memory, sub-agents) available immediately
- Complete auditability: every interaction is a git commit

---

## 2. Architectural Comparison

### Execution Architecture

**`.GITHUB-MODE`** uses a **two-layer architecture**:

1. **Execution Layer**: Builds and runs the full OpenClaw runtime from `src/` via `pnpm install && pnpm build`. The same orchestration, routing, tool policy, and model integrations that run locally execute inside GitHub Actions runners.

2. **Governance Layer**: Machine-readable contracts in `.GITHUB-MODE/runtime/` (manifests, policies, trust levels, parity matrices) are validated in CI. Pre-agent security gates (skill scan, lockfile provenance, policy evaluation) must pass before any agent execution begins. This layer never imports from `src/`; it operates purely on contract data.

The governance layer wraps the execution layer, creating a controlled envelope:

```
Trigger ‚Üí Activation Guard ‚Üí Trust Authorization ‚Üí Pre-Agent Gates
  ‚Üí (Skill Scan ‚Üí Lockfile Provenance ‚Üí Policy Eval)
  ‚Üí Agent Execution (from src/)
  ‚Üí Output (Bot PR / Status Check / Artifact)
  ‚Üí Attestation & Audit
```

**`.GITOPENCLAW`** uses a **single-pipeline architecture**:

```
Issue Created/Commented ‚Üí Workflow Trigger
  ‚Üí Guard (sentinel file check)
  ‚Üí Indicator (üëÄ reaction)
  ‚Üí Install Dependencies (bun install)
  ‚Üí Agent Execution (openclaw agent --local --json)
  ‚Üí Extract Reply ‚Üí Archive Transcript
  ‚Üí Commit State ‚Üí Push (with conflict retry)
  ‚Üí Post Comment ‚Üí Remove Reaction
```

Everything lives in one workflow file (`GITOPENCLAW-WORKFLOW-AGENT.yml`) calling three TypeScript lifecycle scripts. The orchestrator (`GITOPENCLAW-AGENT.ts`, ~494 lines) handles the entire pipeline: session resolution, OpenClaw invocation, state persistence, git operations, and comment posting.

### State Management

**`.GITHUB-MODE`** treats state as **contract artifacts**:
- Runtime contracts (JSON schemas) define behavior boundaries
- Parity matrices track capability alignment across planes
- Implementation scoreboards measure progress
- Workflow artifacts provide per-run evidence
- No persistent mutable state between runs (stateless by design)

**`.GITOPENCLAW`** treats state as **git-committed conversation transcripts**:
- Issue-to-session mappings: `.GITOPENCLAW/state/issues/<number>.json`
- Session transcripts: `.GITOPENCLAW/state/sessions/<id>.jsonl`
- Append-only memory log: `.GITOPENCLAW/state/memory.log` (with `merge=union` git attribute)
- User profile: `.GITOPENCLAW/state/user.md`
- All mutable state lives in `.GITOPENCLAW/state/` and is committed to git after each interaction

This is a fundamental difference: `.GITHUB-MODE` is **stateless between runs** (each workflow is an independent execution with contract-validated inputs); `.GITOPENCLAW` is **stateful across runs** (conversations persist via git commits, sessions resume weeks later).

### Security Models

**`.GITHUB-MODE`** implements a **three-tier trust matrix** with comprehensive threat modeling:

| Trust Tier | Context | Secrets | Privileged Actions |
|-----------|---------|---------|-------------------|
| Untrusted | Fork PRs, unknown actors | None | Read-only |
| Semi-trusted | Internal PRs | Environment-gated, limited | Gate + policy required |
| Trusted | Maintainer environments | Full access | Approval-gated mutations |

Eight threat scenarios (TM-001 through TM-008) are explicitly modeled with mitigations: secret exfiltration, malicious workflow injection, compromised actions, privilege escalation, direct branch mutation, stale credentials, unauthorized dispatch, and artifact leakage.

Pre-agent security gates run before every execution:
- Skill package scan (detect malicious additions)
- Lockfile provenance validation
- Policy evaluation against `command-policy.json`
- Trust-level authorization check

Skills undergo a full quarantine pipeline: intake ‚Üí static scan ‚Üí policy classification ‚Üí dual-approval publish ‚Üí runtime enforcement via digest-keyed allowlist.

**`.GITOPENCLAW`** implements **pragmatic access control**:
- Fail-closed sentinel file (`GITOPENCLAW-ENABLED.md` must exist)
- Collaborator permission check (admin/maintain/write only)
- Bot-comment filtering (prevents infinite loops)
- Scoped commits (only `.GITOPENCLAW/` modified, source code untouched)
- Credentials in GitHub Secrets only

The security model is simpler because the threat surface is smaller: only authorized collaborators can trigger the agent, and the agent's output scope is limited to issue comments and state commits.

---

## 3. Scope and Complexity

### `.GITHUB-MODE` Footprint

| Category | Count | Examples |
|----------|-------|---------|
| Workflows | 23 | build, check, test, command, agent-run, cost, eval, policy, drift, promotion, skill intake/revocation, bot-pr, template-sync |
| Scripts | 25 | Contract validation, security lint, trust enforcement, policy drift, cost/eval thresholds, upstream guard |
| Runtime Contracts | 23 | Manifests, schemas, policies, trust levels, parity matrix, quarantine registries, cost/eval thresholds |
| Test Files | 19 | Contract validation behavior, upstream-additive guardrails, security lint scenarios |
| ADRs | 2 | Runtime boundary ownership, installed-runtime non-regression |
| Design Docs | 8+ | Overview, security trust matrix, skills quarantine, issue loop MVP |

### `.GITOPENCLAW` Footprint

| Category | Count | Examples |
|----------|-------|---------|
| Workflows | 1 | `GITOPENCLAW-WORKFLOW-AGENT.yml` |
| Lifecycle Scripts | 3 | Agent orchestrator, guard, indicator |
| Config Files | 1 | `settings.json` (provider, model, thinking level) |
| Test Files | 1 | `phase0.test.js` (structural validation) |
| Install Scripts | 1 | `GITOPENCLAW-INSTALLER.ts` |
| Documentation | 5 | README, quickstart, possibilities, enabled, not-installed |

The complexity ratio is roughly **20:1** in terms of artifacts. This isn't a flaw‚Äîit reflects fundamentally different problem scopes.

---

## 4. Design Philosophy Contrast

### Contract-First vs. Convention-First

`.GITHUB-MODE` is **contract-first**: every behavior decision is backed by a machine-readable JSON contract. The `runtime-manifest.json` defines components and versions. The `command-policy.json` defines allowed actions and commands. The `trust-levels.json` defines capability boundaries per trust tier. The `parity-matrix.json` tracks which capabilities exist in which plane. If a contract is missing or invalid, execution is blocked.

`.GITOPENCLAW` is **convention-first**: behavior is defined by the presence of files and the structure of the lifecycle scripts. Settings live in one JSON file. The guard is a file-existence check. Session state follows a naming convention (`state/issues/<N>.json` ‚Üí `state/sessions/<id>.jsonl`). There are no schemas to validate against‚Äîthe conventions are enforced by the code itself.

### Governance vs. Simplicity

`.GITHUB-MODE` optimizes for **governance at scale**: multi-reviewer approvals, promotion pipelines, drift detection, attestation chains, skill quarantine with dual sign-off. It assumes a team of maintainers operating automation that affects protected branches and production systems.

`.GITOPENCLAW` optimizes for **immediate productivity**: one person copies a folder, pushes, and has an AI agent answering issues within minutes. Governance is minimal by design‚Äîif you can push to the repo, you can use the agent.

### Stateless Execution vs. Persistent Conversation

`.GITHUB-MODE` workflows are **stateless**: each run validates contracts, executes a task, produces artifacts, and exits. There is no conversation continuity between workflow runs. The "memory" is the contract state and workflow artifacts.

`.GITOPENCLAW` workflows are **stateful**: each run loads prior conversation context from git-committed session transcripts, executes with that context, and commits updated state. A conversation on issue #42 can span weeks with full context reconstruction on each turn.

### Fork-Context Build vs. Pre-built Runtime

`.GITHUB-MODE` **builds OpenClaw from source** on each run: workflows execute `pnpm install && pnpm build` and run the agent from `dist/`. This ensures the runtime matches the exact repository state and allows governance scripts to validate the build.

`.GITOPENCLAW` **installs OpenClaw as a dependency**: `package.json` declares `"openclaw": "^2026.2.19"` and the workflow runs `bun install` in the `.GITOPENCLAW/` directory. This is faster (no build step) but decouples the agent runtime from the repository's source code.

---

## 5. Capability Comparison

| Capability | `.GITHUB-MODE` | `.GITOPENCLAW` |
|-----------|---------------|----------------|
| Agent execution | ‚úÖ Full runtime from source | ‚úÖ Full runtime from npm |
| Multi-turn conversation | ‚ùå Stateless per run | ‚úÖ Git-backed session persistence |
| Trust-tiered security | ‚úÖ Three tiers with threat model | ‚ö†Ô∏è Binary (collaborator or not) |
| Contract validation | ‚úÖ 23 machine-readable contracts | ‚ùå No contracts |
| Skill quarantine | ‚úÖ Full intake pipeline | ‚ùå No skill gating |
| Promotion pipelines | ‚úÖ Dev ‚Üí staging ‚Üí prod gates | ‚ùå Not applicable |
| Drift detection | ‚úÖ Policy and template drift | ‚ùå No drift monitoring |
| Cost/eval thresholds | ‚úÖ Budget and quality gates | ‚ùå No cost controls |
| Bot PR generation | ‚úÖ Structured PR workflow | ‚ùå Comments only |
| Issue-based interaction | ‚úÖ (via issue-agent workflow) | ‚úÖ (primary interface) |
| Slash commands | ‚úÖ (via command workflow) | ‚ùå Not implemented |
| Multi-entity collaboration | ‚úÖ (envelope protocol) | ‚ùå Single agent |
| Template management | ‚úÖ (sync and drift detection) | ‚ùå No templates |
| Setup time | ‚è±Ô∏è Days/weeks | ‚è±Ô∏è 5 minutes |
| Maintenance burden | üìà High (contracts, workflows, scripts) | üìâ Low (single workflow) |

---

## 6. Overlap and Potential Convergence

### Shared Patterns

Both systems share several design patterns:

1. **Fail-closed activation**: `.GITHUB-MODE` uses `ACTIVE.md` as a kill switch; `.GITOPENCLAW` uses `GITOPENCLAW-ENABLED.md`. Same pattern, different files.

2. **Source code immutability**: Both prohibit modifying files outside their own directories. `.GITHUB-MODE` enforces this via `check-upstream-additions-only.ts`; `.GITOPENCLAW` scopes git commits to `.GITOPENCLAW/` only.

3. **OpenClaw as runtime**: Both execute the full OpenClaw agent with its 30+ tools, not a stripped-down version. The difference is source-built vs. npm-installed.

4. **GitHub-native credentials**: Both store API keys in GitHub Secrets, never in committed files.

5. **Reaction-based UX signaling**: Both use GitHub reactions (üëÄ) to indicate agent activity.

### Divergence Points

| Pattern | `.GITHUB-MODE` | `.GITOPENCLAW` |
|---------|---------------|----------------|
| State durability | Stateless (artifacts only) | Git-committed sessions |
| Trust model | Three tiers with policies | Binary collaborator check |
| Output channel | Bot PRs, status checks, artifacts | Issue comments |
| Configuration | 23 contract files | 1 settings file |
| Validation | Schema-driven, CI-enforced | Code-enforced conventions |
| Scalability model | Multi-entity, cross-repo | Single repo, single agent |

### Convergence Opportunity

`.GITOPENCLAW`'s issue-agent pattern is strikingly similar to `.GITHUB-MODE`'s `github-mode-issue-agent.yml` design document. The key difference is that `.GITOPENCLAW` implements it as a complete, working system, while `.GITHUB-MODE` designs it as one workflow within a larger governance framework.

A natural convergence path:
1. `.GITOPENCLAW` could adopt `.GITHUB-MODE`'s trust-level gating for more nuanced access control
2. `.GITHUB-MODE` could adopt `.GITOPENCLAW`'s session persistence model for stateful agent interactions
3. Both could share a common activation guard pattern (sentinel file + collaborator check)
4. `.GITOPENCLAW` could evolve into the "easy on-ramp" that graduates into `.GITHUB-MODE` when governance needs grow

---

## 7. Maturity and Readiness

| Dimension | `.GITHUB-MODE` | `.GITOPENCLAW` |
|-----------|---------------|----------------|
| Status | Under active development | Under active development |
| Target launch | March 2026 | Functional now (Phase 0) |
| Test coverage | 19 test files, fixture-driven | 1 structural test file |
| Documentation | Extensive (ADRs, design docs, threat models) | Practical (quickstart, possibilities) |
| Running code | Workflows + scripts (contract validation) | End-to-end working agent |
| Production readiness | Pre-production (governance framework) | Pre-production (functional prototype) |

A notable contrast: `.GITHUB-MODE` has more documentation and design artifacts than running code, while `.GITOPENCLAW` has more running code than documentation. This reflects their different development approaches‚Äîtop-down governance design vs. bottom-up implementation.

---

## 8. Summary: Two Philosophies, One Goal

Both `.GITHUB-MODE` and `.GITOPENCLAW` share the vision of making OpenClaw run natively on GitHub. They diverge on **who they serve** and **what they optimize for**:

**`.GITHUB-MODE`** is for teams that need **governed, auditable, approval-gated automation** at scale. It answers: *"How do we safely run AI-powered automation across a team with different trust levels, promotion gates, and compliance requirements?"*

**`.GITOPENCLAW`** is for developers who want **an AI agent in their repo right now** with zero infrastructure. It answers: *"How do we make deploying an AI agent as simple as copying a folder?"*

Neither replaces the other. `.GITOPENCLAW` is the fast path to value; `.GITHUB-MODE` is the governance framework for operating at scale. Together, they represent two points on a spectrum: from individual developer productivity to team-scale governed automation‚Äîboth running on infrastructure that already exists in every GitHub repository.

---

*Analysis generated 2026-02-28. Based on examination of all files in `.GITHUB-MODE/` (23 workflows, 25 scripts, 23 runtime contracts, 19 tests, 8+ design docs) and `.GITOPENCLAW/` (1 workflow, 3 lifecycle scripts, 1 config, 5 docs, 1 test).*
