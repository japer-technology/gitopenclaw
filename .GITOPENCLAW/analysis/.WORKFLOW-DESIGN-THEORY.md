# Workflow Design Theory

An analysis of the GitHub Actions workflows defined in `.github/workflows/` and the
composite actions they depend on in `.github/actions/`.

---

## 1. CI (`ci.yml`)

**Trigger:** `push` to `main`, all `pull_request` events.

**Effect:** The primary continuous-integration pipeline. It enforces code quality, correctness,
and cross-platform compatibility on every change.

### Design theory

The workflow is built around **progressive filtering** to avoid wasting compute:

1. **`docs-scope`** — A lightweight first job runs the `detect-docs-changes` composite action.
   If every changed file is documentation (`docs/`, `*.md`, `*.mdx`), it outputs
   `docs_only=true` and all expensive jobs (test, build, Windows, macOS, Android) are skipped
   entirely. A companion `docs_changed` flag enables a dedicated `check-docs` job only when
   doc files are actually touched.

2. **`changed-scope`** — A second filtering job categorises changed files into three scopes:
   `run_node` (TypeScript/tooling), `run_macos` (Swift/Xcode), and `run_android` (Gradle).
   Pull requests that only touch native code skip the full Node test matrix, and vice versa.
   Push events to `main` always enable broad coverage as a fail-safe.

3. **`check`** — Type-checking (`pnpm tsgo`), linting (Oxlint), formatting (Oxfmt), and a
   custom UI security lint (`lint:ui:no-raw-window-open`) run on all non-docs changes,
   gating later jobs.

4. **`build-artifacts`** — Builds `dist/` once and uploads it as an artifact, shared by
   downstream jobs (Windows lint lane, release-check) to avoid redundant builds.

5. **`checks`** (matrix) — Runs the Vitest test suite under Node and, on PRs, also under Bun.
   The Bun lane is skipped on push-to-main to save time. A `protocol:check` lane validates
   the generated protocol models. Vitest JSON reports and a "slowest tests" summary are
   uploaded as artifacts for debugging slow test suites.

6. **`release-check`** — Validates `npm pack` contents after build, but only on push to
   `main` (not on PRs), keeping release integrity in check without slowing PR feedback.

7. **`checks-windows`** — Mirrors the Linux test/lint/protocol matrix on a Windows runner with
   two sharded test jobs. Includes a best-effort step to exclude the workspace from Windows
   Defender scanning to reduce I/O overhead.

8. **`macos`** — Runs TS tests, Swift linting (SwiftLint + SwiftFormat), Swift build, and
   Swift test sequentially on a single macOS runner. The design note explains that GitHub
   limits macOS concurrency to 5 per org, so consolidating into one job lets 5 PRs run
   simultaneously instead of starving the queue.

9. **`ios`** — Currently disabled (`if: false`). When enabled, it would generate the Xcode
   project via XcodeGen, run xcodebuild tests on a simulator, and enforce a coverage gate.

10. **`android`** — Builds the debug APK and runs unit tests via Gradle on an Ubuntu runner
    with the Android SDK installed.

11. **`skills-python`** — Lints Python skill scripts with `ruff` and runs `pytest` to keep
    the Python portions of the skill system healthy.

12. **`secrets`** — A security-focused job that runs `detect-secrets`, `detect-private-key`,
    `zizmor` (GitHub workflow auditing, scoped to changed workflow files only), and
    `pnpm-audit-prod` for production dependency auditing.

13. **`deadcode`** — A report-only dead-code detection matrix (knip, ts-prune,
    ts-unused-exports). Currently disabled (`if: false`) while initial findings are triaged.

14. **`check-docs`** — Runs `pnpm check:docs` (format, lint, broken links) only when
    `docs_changed` is true.

### Concurrency

Uses `cancel-in-progress` for PRs so superseded runs are killed, but push events to `main`
run to completion.

---

## 2. Labeler (`labeler.yml`)

**Trigger:** `pull_request_target` (opened/synchronize/reopened), `issues` (opened),
`workflow_dispatch`.

**Effect:** Automatically classifies every PR and issue with metadata labels to power
triage, filtering, and automation.

### Design theory

Three labeling strategies run in parallel jobs:

1. **Path-based labels** — Uses the official `actions/labeler` with `.github/labeler.yml`
   to apply fine-grained labels (channel, app, gateway, docs, cli, commands, scripts, docker,
   agents, security, extensions) based on which files a PR touches. `sync-labels: true`
   removes stale path labels when files are no longer changed.

2. **PR size labels** — A `github-script` step counts non-doc, non-lockfile changed lines
   and assigns a size label (XS < 50, S < 200, M < 500, L < 1000, XL >= 1000). This helps
   reviewers prioritise small PRs for faster merge velocity.

3. **Contributor trust labels** — Checks if the PR/issue author is a member of the
   `maintainer` team. If not, queries the search API for their count of merged PRs in the
   repo and applies `trusted-contributor` (>= 4 merged) or `experienced-contributor`
   (>= 10 merged). These labels signal review confidence.

4. **`backfill-pr-labels`** — A `workflow_dispatch`-only job that retroactively applies size
   and contributor labels to all open PRs, with configurable pagination. Useful after
   introducing new label rules.

5. **`label-issues`** — Applies the same maintainer/trusted/experienced contributor labels
   to newly opened issues.

### Security

Uses a GitHub App token (`actions/create-github-app-token`) instead of `GITHUB_TOKEN` to
operate on `pull_request_target` events safely and to read team membership.

---

## 3. Auto Response (`auto-response.yml`)

**Trigger:** `issues` (opened/edited/labeled), `issue_comment` (created),
`pull_request_target` (labeled).

**Effect:** An automated community management bot that responds to, closes, and locks
issues/PRs based on labels and content patterns.

### Design theory

The workflow implements a **rule-based triage engine**:

- **Label-triggered rules** — Labels prefixed with `r:` trigger canned responses. For
  example, `r: skill` closes the issue and redirects to ClawhHub; `r: support` redirects to
  Discord; `r: moltbook` closes, locks, and explains non-affiliation.

- **Content-triggered rules** — Comment bodies are scanned for keyword triggers (e.g.
  "testflight", "moltbook") and auto-replied to without requiring a label.

- **Maintainer ping protection** — Counts distinct maintainer `@mentions` in issue/comment
  text. If 3+ maintainers are pinged (or the whole team is mentioned), a warning comment is
  posted asking the author to be patient.

- **Dirty PR detection** — PRs labeled `dirty` or with > 20 labels get an explanatory
  comment and are closed. PRs labeled `invalid` are silently closed. Issues labeled `invalid`
  are closed as `not_planned`.

- **Auto-labeling on content** — Issues with "security" in the title get the `security`
  label; "testflight" triggers `r: testflight`; "moltbook" triggers `r: moltbook`.

- **`trigger-response` meta-label** — Adding this label forces rule re-evaluation, then the
  label is removed. This allows maintainers to manually re-trigger responses.

---

## 4. Stale (`stale.yml`)

**Trigger:** Daily schedule (`cron: "17 3 * * *"`), `workflow_dispatch`.

**Effect:** Automatically marks and closes inactive issues and PRs to keep the tracker
focused on actively maintained work.

### Design theory

- Issues go stale after **7 days** of inactivity, then close after **5 more days**.
- PRs go stale after **5 days**, then close after **3 more days**.
- Exempt labels: `enhancement`, `maintainer`, `pinned`, `security`, `no-stale` for issues;
  `maintainer`, `no-stale` for PRs.
- All assigned items are exempt (`exempt-all-assignees: true`), recognising that assigned
  work may be in progress offline.
- Stale labels are removed when the item is updated (`remove-stale-when-updated: true`).
- Close messages direct users to retry on the latest release (issues) or post in
  `#pr-thunderdome-dangerzone` on Discord (PRs) as an escape hatch.
- `operations-per-run: 10000` ensures even large backlogs are processed in a single run.

---

## 5. Docker Release (`docker-release.yml`)

**Trigger:** `push` to `main` or version tags (`v*`), excluding docs/markdown/agents/skills.

**Effect:** Builds and publishes multi-architecture Docker images to the GitHub Container
Registry (GHCR).

### Design theory

The workflow uses a **split-build, merge-manifest** pattern:

1. **`build-amd64`** — Builds and pushes an `amd64` image on an Ubuntu x86 runner.
2. **`build-arm64`** — Builds and pushes an `arm64` image on an Ubuntu ARM runner.
3. **`create-manifest`** — After both builds complete, creates a multi-platform OCI manifest
   that combines both architectures under unified tags.

**Tagging strategy:**
- Push to `main` → `:main` tag (rolling latest from default branch).
- Version tag `v*` → `:<version>` tag, plus `:latest` only for stable semver releases
  (regex excludes prerelease suffixes like `-beta.N`).

**Caching:** Each architecture uses registry-based layer caching
(`type=registry,ref=...cache:<arch>,mode=max`) for fast incremental rebuilds.

**Concurrency:** `cancel-in-progress: false` ensures release builds always complete; a
concurrent push won't abort a running release.

---

## 6. Install Smoke (`install-smoke.yml`)

**Trigger:** `push` to `main`, all `pull_request` events, `workflow_dispatch`.

**Effect:** Validates the end-to-end install experience by running Docker-based installer
smoke tests.

### Design theory

- Skips entirely for docs-only changes (reuses `detect-docs-changes`).
- Uses `pnpm install --ignore-scripts --frozen-lockfile` for a minimal dependency install
  (the test harness doesn't need a full build).
- Tests the publicly hosted install scripts (`https://openclaw.ai/install.sh` and
  `install-cli.sh`).
- On PRs, the non-root install path is skipped (`CLAWDBOT_INSTALL_SMOKE_SKIP_NONROOT=1`) to
  save time; the full matrix runs on push to `main`.
- `CLAWDBOT_INSTALL_SMOKE_SKIP_PREVIOUS=1` skips upgrade-from-previous-version tests,
  keeping the fast path focused on clean installs.

---

## 7. Workflow Sanity (`workflow-sanity.yml`)

**Trigger:** `push` to `main`, all `pull_request` events.

**Effect:** Validates the workflow files themselves for correctness and hygiene.

### Design theory

Two complementary checks:

1. **`no-tabs`** — A Python script scans all `.yml`/`.yaml` files under `.github/workflows/`
   for tab characters and fails if any are found. YAML allows tabs but they cause subtle
   indentation bugs; enforcing spaces-only prevents misparse.

2. **`actionlint`** — Runs the `actionlint` static analyser against all workflows to catch
   syntax errors, type mismatches, and deprecated features. A companion Python script
   (`check-composite-action-input-interpolation.py`) disallows direct `${{ inputs.* }}`
   interpolation in composite action `run:` blocks, which is a known injection vector.

---

## 8. Sandbox Common Smoke (`sandbox-common-smoke.yml`)

**Trigger:** `push` to `main` or `pull_request`, but only when sandbox-related files change
(`Dockerfile.sandbox`, `Dockerfile.sandbox-common`, `scripts/sandbox-common-setup.sh`).

**Effect:** Validates that the shared sandbox Docker base image builds correctly and runs as
the expected non-root user.

### Design theory

- **Path-scoped trigger** — Only runs when sandbox infrastructure files are modified,
  avoiding unnecessary Docker builds on unrelated changes.
- Builds a minimal Debian base image with a `sandbox` user, then runs the shared setup
  script (`sandbox-common-setup.sh`) with minimal options (no pnpm, no Bun, no Homebrew).
- The final assertion verifies the container runs as user `sandbox`, ensuring the
  principle-of-least-privilege holds.

---

## 9. GITOPENCLAW Workflow Agent (`GITOPENCLAW-WORKFLOW-AGENT.yml`)

**Trigger:** `issues` (opened), `issue_comment` (created).

**Effect:** Runs an AI-powered agent that can respond to issues and comments, gated behind
authorization and a feature flag.

### Design theory

- **Authorization gate** — Checks the actor's repository permission via the GitHub API.
  Only `admin`, `maintain`, or `write` collaborators can trigger the agent, preventing abuse.
- **Bot-comment filter** — The `if` condition excludes comments from `github-actions[bot]`
  to prevent infinite loops.
- **Feature flag** — A `Guard` step runs `.GITOPENCLAW/lifecycle/GITOPENCLAW-ENABLED.ts`,
  allowing the agent to be disabled without removing the workflow.
- **Indicator** — A `Preinstall` step runs `GITOPENCLAW-INDICATOR.ts` to post a visual
  indicator (e.g. a reaction or comment) that the agent is processing.
- **Agent execution** — Installs dependencies in `.GITOPENCLAW/` and runs the main agent
  script with `ANTHROPIC_API_KEY` for LLM access and `GITHUB_TOKEN` for repo operations.

---

## Composite Actions

### `detect-docs-changes`

Outputs `docs_only` and `docs_changed` booleans by diffing changed files against
`docs/` and `*.md/*.mdx` patterns. Uses `git diff` (no API calls) and fails safe to
`false` if the diff cannot be computed.

### `setup-node-env`

A reusable environment setup action that initialises git submodules (with retry), installs
Node 22 via `actions/setup-node`, activates pnpm via corepack, optionally installs Bun,
and runs `pnpm install`. Used by CI, check-docs, and other Node-dependent jobs.

### `setup-pnpm-store-cache`

Activates pnpm via corepack with retry logic and restores the pnpm store from
`actions/cache`, keyed on `pnpm-lock.yaml` hash and runner OS. Provides fast, reproducible
dependency resolution.

---

## Cross-Cutting Design Patterns

| Pattern | Where used | Why |
|---|---|---|
| **Progressive filtering** | CI (`docs-scope` → `changed-scope` → per-platform jobs) | Avoids running expensive jobs when changes don't warrant them |
| **Concurrency groups with cancel-in-progress** | CI, Install Smoke, Workflow Sanity, Sandbox Smoke | Kills superseded PR runs to free capacity; push events run to completion |
| **GitHub App tokens** | Labeler, Auto Response, Stale | Provides elevated permissions (team membership reads, cross-event writes) without using PATs |
| **Fail-safe defaults** | `detect-docs-changes`, `changed-scope` | If detection fails, assume the broadest scope (run everything) |
| **Artifact sharing** | CI (`build-artifacts` → `release-check`, `checks-windows`) | Build once, test many times |
| **Split-arch build + manifest merge** | Docker Release | Native-speed builds on matching hardware, unified multi-arch image |
| **Path-scoped triggers** | Sandbox Smoke, Docker Release (paths-ignore) | Run only when relevant files change |
| **Content-based auto-triage** | Auto Response, Labeler | Reduce maintainer toil by automating repetitive classification and responses |
